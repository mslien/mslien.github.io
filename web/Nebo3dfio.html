<!DOCTYPE html>
<html lang="vi">
<head>

<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>NeboN Combo — Hình ảnh (N) + Âm thanh (C) [patched]</title>
<script src="./jquery/gsap.min.js">

function tryScrollFromMarker(el){
  try{
    const k = parseFloat(el && el.getAttribute ? el.getAttribute('data-scroll') : NaN);
    if(isNaN(k)) return;

    const c = document.getElementById('svgContainer');
    if(!c) return;

    const ratio = Math.max(0, Math.min(1, k/2)); // 0,1,2 -> 0,0.5,1
    const rangeX = (c.scrollWidth  || 0) - (c.clientWidth  || 0);
    const rangeY = (c.scrollHeight || 0) - (c.clientHeight || 0);

    const wantX = c.classList.contains('opp-x');
    const wantY = c.classList.contains('opp-y');

    // trượt được thì trượt, không thì giữ nguyên
    if(wantX){
      if(rangeX > 2) c.scrollTo({ left: rangeX * ratio, behavior:'smooth' });
      return;
    }
    if(wantY){
      if(rangeY > 2) c.scrollTo({ top:  rangeY * ratio, behavior:'smooth' });
      return;
    }

    // fallback: trục nào có range lớn hơn
    if(rangeY >= rangeX){
      if(rangeY > 2) c.scrollTo({ top: rangeY * ratio, behavior:'smooth' });
    }else{
      if(rangeX > 2) c.scrollTo({ left: rangeX * ratio, behavior:'smooth' });
    }
  }catch(e){}
}

</script>
<script>
// __LAYOUT_LOCK_STABLE_V1__
window.__layoutLocked = false; // true while PLAY
window.__lockLayout = function(on){ window.__layoutLocked = !!on; };

// === NOTE + GREY PALETTE HOOK (based on original Nebo3df timing; color only) ===
(function(){
  function getVar(name, fallback){
    try{
      // vars are overridden on body.invert-mode, so read from BODY first
      const v = getComputedStyle(document.body).getPropertyValue(name).trim();
      if(v) return v;
    }catch(_){}
    try{
      const v2 = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      return v2 || fallback;
    }catch(_){ return fallback; }
  }

  function norm(c){
    return (String(c||'').trim().toLowerCase()
      .replace(/\s+/g,'')
      .replace(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/,'#$1$1$2$2$3$3'));
  }
  function isAuthorGrey(v){
    const s = norm(v);
    return (s === '#808080' || s === 'rgb(128,128,128)' || s === 'rgba(128,128,128,1)');
  }

  function roleOf(el){
    try{
      const owner = el.closest ? el.closest('[data-role]') : null;
      const r = (el.getAttribute('data-role') || (owner && owner.getAttribute('data-role')) || '').toLowerCase();
      return r;
    }catch(_){ return ''; }
  }

  function tagGrey(el){
    // detect authoring grey from attr or inline style
    const s = el.getAttribute('stroke');
    const f = el.getAttribute('fill');
    const st = (el.getAttribute('style')||'');
    const mStroke = st.match(/stroke\s*:\s*([^;]+)/i);
    const mFill   = st.match(/fill\s*:\s*([^;]+)/i);
    const ss = mStroke ? mStroke[1] : null;
    const ff = mFill ? mFill[1] : null;

    if(isAuthorGrey(s) || isAuthorGrey(f) || isAuthorGrey(ss) || isAuthorGrey(ff)){
      try{ el.setAttribute('data-grey','1'); }catch(_){}
      return true;
    }
    return false;
  }

  function apply(svg){
    const VAR_NOTEA = 'var(--noteA)';
    const VAR_NOTEZ = 'var(--noteZ)';
    const VAR_GREY  = 'var(--grey)';
    const VAR_RECTG = 'var(--rect-grey)';

    // 1) NOTE roles
    svg.querySelectorAll('[data-role="note"],[data-role="noteA"],[data-role="noteZ"],[data-role="notea"],[data-role="notez"],[data-role="note"] *,[data-role="noteA"] *,[data-role="noteZ"] *,[data-role="notea"] *,[data-role="notez"] *').forEach(el=>{
      try{
        const tag = (el.tagName||'').toLowerCase();
        if(!tag) return;
        // only stroke-like elements (don't touch <g>)
        if(['path','line','polyline','polygon','circle','ellipse','rect','text','tspan'].indexOf(tag)===-1) return;

        const role = roleOf(el);
        if(!role || role.indexOf('note')!==0) return;

        const color = (role === 'note') ? VAR_GREY : ((role === 'notez') ? VAR_NOTEZ : VAR_NOTEA);
        // NOTE/GREY: do NOT force opacity here; timeline (data-hue) controls visibility
        // Apply NOTE color:
        // - WRITE/text (fill-based): set fill, remove stroke
        // - stroke paths/lines: set stroke
        try{
          const isText = (tag === 'text' || tag === 'tspan');
          const fillAttr = (el.getAttribute('fill') || '').trim().toLowerCase();
          const styleAttr = (el.getAttribute('style') || '');
          const hasFillStyle = /fill\s*:/i.test(styleAttr);
          const fillIsNone = (fillAttr === 'none');
          const isWriteFillPath =
            (tag === 'path') && !fillIsNone && (fillAttr !== '' || hasFillStyle || el.getAttribute('data-fill') === '1' || el.getAttribute('data-write') === '1');

          if (isText || isWriteFillPath){
            try{ el.style.setProperty('fill', color, 'important'); }catch(_){}
            try{ el.style.setProperty('fill-opacity', '1', 'important'); }catch(_){}
            try{ el.style.setProperty('stroke', 'none', 'important'); }catch(_){}
            try{ el.style.setProperty('stroke-opacity', '0', 'important'); }catch(_){}
          } else {
            try{ el.style.setProperty('stroke', color, 'important'); }catch(_){}
            try{ el.style.setProperty('stroke-opacity', '1', 'important'); }catch(_){}
          }
        }catch(_){}
        // DO NOT touch dasharray: keep original timing/handwrite behavior
      }catch(_){}
    });

    // 2) GREY tagging + apply color (authoring #808080 -> palette)
    svg.querySelectorAll('path,line,polyline,polygon,rect,circle,ellipse,text,tspan').forEach(el=>{
      try{
        const dt = (el.getAttribute('data-type') || '').toLowerCase();
        const isGreyType = dt.split(/\s+/).includes('grey');
        if(isGreyType){
          try{ el.setAttribute('data-grey','1'); }catch(_){ }
        }
        if(el.getAttribute('data-grey')==='1' || isGreyType || tagGrey(el)){
          // apply stroke/fill as "pencil grey" according to role
          const tag = (el.tagName||'').toLowerCase();

          // stroke
          try{
            // if element has stroke or is a line-like element, color it
            const hasStroke = el.getAttribute('stroke') != null || /stroke\s*:/i.test(el.getAttribute('style')||'') || ['path','line','polyline','polygon','circle','ellipse','rect'].includes(tag);
            if(hasStroke){
              el.style.setProperty('stroke', VAR_GREY, 'important');
              el.style.setProperty('stroke-opacity', '1', 'important');
            }
          }catch(_){}

          // fill (for rect/ellipse highlight grey)
          try{
            const fillAttr = (el.getAttribute('fill')||'').trim().toLowerCase();
            const wantFill = (fillAttr && fillAttr !== 'none' && fillAttr !== 'transparent') || /fill\s*:/i.test(el.getAttribute('style')||'');
            if(wantFill){
              el.style.setProperty('fill', VAR_RECTG, 'important');
            }
          }catch(_){}
        }
      }catch(_){}
    });

    // 3) PATTERNS: if hatch patterns use currentColor, map to grey so it won't turn pure b/w
    try{
      svg.querySelectorAll('defs pattern[id^="pat"] [stroke="currentColor"], defs pattern[id^="pat"] [fill="currentColor"]').forEach(el=>{
        try{
          if(el.getAttribute('stroke')==='currentColor') el.setAttribute('stroke', grey);
          if(el.getAttribute('fill')==='currentColor')   el.setAttribute('fill', grey);
        }catch(_){}
      });
    }catch(_){}
  }

  function run(){
    const host = document.getElementById('svgContainer') || document.body;
    const svg  = host && host.querySelector ? host.querySelector('svg') : null;
    if(svg) apply(svg);
  }

  function hook(){
    run();

    // apply again when SVG content changes (load new file, re-render)
    try{
      const host = document.getElementById('svgContainer') || document.body;
      const mo = new MutationObserver(()=>run());
      mo.observe(host, {childList:true, subtree:true});
    }catch(_){}

    // apply again when invert-mode toggles
    try{
      const mo2 = new MutationObserver(()=>run());
      mo2.observe(document.body, {attributes:true, attributeFilter:['class']});
    }catch(_){}
  }

  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', hook);
  }else{
    hook();
  }
})();</script>
<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: #ffffff; /* chế độ bình thường: nền trắng */
  color: #000000;
}

:root{
  /* ===== NOTE (light background) ===== */
  --noteA: #001373;   /* blue */
  --noteZ: #731300;   /* (bạn ghi là purple nhưng mã này là đỏ nâu) */

  /* ===== GREY ===== */
  --greyL: #666666;   /* light bg grey */
  --greyD: #999999;  /* dark bg grey */

  /* active (light mode default) */
  --grey: var(--greyL);
  --rect-grey: var(--greyL);
}

/* ===== Base backgrounds ===== */
body{
  background:#ffffff;
  color:#000000;
}
#svgContainer{
  background:#ffffff;
}

/* ===== DARK MODE (invert-mode) ===== */
body.invert-mode{
  background:#000000;
  color:#ffffff;

  /* NOTE (dark background) */
  --noteA: #FFEC8C;   /* yellow */
  --noteZ: #8cecff;   /* cyan (bạn muốn xanh lá thì đổi thành #6DFF6D) */

  /* GREY (dark background) */
  --grey: var(--greyD);
  --rect-grey: var(--greyD);
}
body.invert-mode #svgContainer{
  background:#000000;
}


/* Invert toàn bộ SVG (kể cả eraser, highlight…) */
body.invert-mode #svgContainer svg {
  filter: invert(1);
}



/* NOTE + GREY: keep readable in invert-mode
   - Parent SVG is inverted in dark mode.
   - For note/grey elements, we apply the same invert filter on the element (double-invert),
     so their own colors stay as-authored / as-set by CSS vars.
*/
#svgContainer svg [data-role="note"],
#svgContainer svg [data-role="noteA"],
#svgContainer svg [data-role="noteZ"],
#svgContainer svg [data-role="notea"],
#svgContainer svg [data-role="notez"],
#svgContainer svg [data-grey="1"],
#svgContainer svg .grey,
#svgContainer svg [data-type~="grey"]{
  filter: none !important;
}

/* In dark mode: double-invert note/grey so they keep their intended colors */
body.invert-mode #svgContainer svg [data-role="note"],
body.invert-mode #svgContainer svg [data-role="noteA"],
body.invert-mode #svgContainer svg [data-role="noteZ"],
body.invert-mode #svgContainer svg [data-role="notea"],
body.invert-mode #svgContainer svg [data-role="notez"],
body.invert-mode #svgContainer svg [data-grey="1"],
body.invert-mode #svgContainer svg .grey,
body.invert-mode #svgContainer svg [data-type~="grey"]{
  filter: invert(1) !important;
}

/* NOTE colors (role-separated; do NOT touch fill to preserve handwriting/fill effects) */
/* NOTE = GREY (pencil) */
#svgContainer svg [data-role="note"],
#svgContainer svg [data-role="note"] *{
  stroke: var(--grey) !important;
  stroke-opacity: 1 !important;
}
/* NOTE A */
#svgContainer svg [data-role="noteA"],
#svgContainer svg [data-role="notea"],
#svgContainer svg [data-role="noteA"] *,
#svgContainer svg [data-role="notea"] *{
  stroke: var(--noteA) !important;
  stroke-opacity: 1 !important;
}
/* NOTE Z */
#svgContainer svg [data-role="noteZ"],
#svgContainer svg [data-role="notez"],
#svgContainer svg [data-role="noteZ"] *,
#svgContainer svg [data-role="notez"] *{
  stroke: var(--noteZ) !important;
  stroke-opacity: 1 !important;
}

/* GREY colors: apply to strokes and to grey rect fills (if any) */
#svgContainer svg [data-grey="1"],
#svgContainer svg .grey,
#svgContainer svg [data-type~="grey"],
#svgContainer svg [data-grey="1"] * ,
#svgContainer svg .grey *,
#svgContainer svg [data-type~="grey"] *{
  stroke: var(--grey) !important;
  fill: var(--rect-grey) !important;
  stroke-opacity: 1 !important;
}
/* Nếu sau này có hình <img> trong container cũng đảo luôn */
body.invert-mode #svgContainer img {
  filter: invert(1);
}

/* Nút bật/tắt invert */
#invertToggle{
  position: fixed;

  /* đẩy vào trong đủ xa để không bị che */
  top: calc(8px + env(safe-area-inset-top, 0px));
  left: calc(48px + env(safe-area-inset-left, 0px));

  width: 32px;
  height: 32px;
  border-radius: 50%;

  z-index: 9999;
  pointer-events: auto;
}


/* Ẩn nút NO/SPLIT phụ (giữ logic nội bộ, không chiếm chỗ UI) */
#noToggleBtn{ display:none !important; }
/* Màu sắc, bo góc, shadow, font... lấy theo .adaptiveBtn */

.adaptiveBtn {
  --btn-bg: #3a3a3a;   /* ~25% */
  --btn-fg: #c5c5c5;   /* ~90% */

  background: transparent;
  color: var(--btn-bg);
  border: 2px solid var(--btn-fg);
  width:32px;
  height:32px;
  padding: 0px 5px;
  font-size: 20px;
  font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  cursor: pointer;

}

/* Khi invert/dark-mode thì đảo ngược bg/fg */
body.invert-mode .adaptiveBtn,
body.gif-invert .adaptiveBtn,
body.svg-invert .adaptiveBtn,
body.invert .adaptiveBtn {
  --btn-bg: #c5c5c5;
  --btn-fg: #3a3a3a;
}

/* WRITE (fill-based): role note = GREY (2 modes) */
#svgContainer svg [data-role="note"] :is(path, text, tspan){
  fill: var(--grey) !important;
  stroke: none !important;
}

/* === PATCH: thicken math formula glyphs without moving === */
#svgContainer svg text,
#svgContainer svg tspan{
  paint-order: stroke fill;
  stroke: currentColor;        /* viền cùng màu chữ */
  stroke-width: 1px;        /* thử 0.25 → 0.6 */
  stroke-linejoin: round;
    stroke-linecap: round;

}


/* Chặn caret/selection khi click trong Chrome */
#svgContainer, #svgContainer *{
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent; /* đỡ flash highlight trên mobile */
}

/* Nếu #svgContainer có thể focus (tabindex) thì tắt vòng focus */
#svgContainer:focus{ outline: none; }

/* (tuỳ chọn) nếu caret xuất hiện do text trong SVG */
#svgContainer svg text, 
#svgContainer svg tspan{
  -webkit-user-select: none;
  user-select: none;
}


/* --- FORCE SCROLL AXIS for opp modes (added) --- */
#svgContainer.opp-x{overflow-x:auto !important; overflow-y:hidden !important;}
#svgContainer.opp-y{overflow-y:auto !important; overflow-x:hidden !important;}


/* __SCROLL_VIEN_BTN_CSS_V1__ */
#svgContainer.ps-lock{
  overflow:hidden !important;
  overflow-x:hidden !important;
  overflow-y:hidden !important;
  overscroll-behavior:none !important;
  touch-action:none !important;
}
#svgContainer.ps-free.opp-x{ overflow-x:auto !important; overflow-y:hidden !important; }
#svgContainer.ps-free.opp-y{ overflow-y:auto !important; overflow-x:hidden !important; }
#svgContainer.ps-free:not(.opp-x):not(.opp-y){ overflow:auto !important; }
</style>

<script>
// ===== Edge Vietnamese TTS enforcement (auto-pick vi-VN voice) =====
(function(){
  try {
    var _speak = window.speechSynthesis && window.speechSynthesis.speak ? window.speechSynthesis.speak.bind(window.speechSynthesis) : null;
    if(!_speak) return;
    var chosen = null;
    function pickVi(){
      try {
        var vs = window.speechSynthesis.getVoices() || [];
        // Prefer exact vi-VN, then any lang containing 'vi', then names mentioning Vietnamese
        var v = vs.find(function(v){ return (v.lang||'').toLowerCase() === 'vi-vn'; })
             || vs.find(function(v){ return /(^|[-_])vi($|[-_])/i.test(v.lang||''); })
             || vs.find(function(v){ return /vietnam/i.test(v.name||''); });
        return v || null;
      } catch(e){ return null; }
    }
    function ensureLoaded(cb){
      var tries = 0;
      (function loop(){
        tries++;
        var vs = window.speechSynthesis.getVoices() || [];
        if(vs && vs.length){ cb && cb(); return; }
        if(tries < 50) setTimeout(loop, 100);
        else cb && cb(); // give up but still call
      })();
    }
    // Patch speak
    window.speechSynthesis.speak = function(u){
      try {
        chosen = chosen || pickVi();
        if(!chosen){ chosen = pickVi(); }
        if(chosen){
          try { u.voice = chosen; } catch(_){}
          if(!u.lang) try { u.lang = chosen.lang || 'vi-VN'; } catch(_){}
        } else {
          if(!u.lang) try { u.lang = 'vi-VN'; } catch(_){}
        }
      } catch(_){}
      return _speak(u);
    };
    // Refresh when voices arrive
    window.speechSynthesis.onvoiceschanged = function(){ chosen = pickVi(); };
    // Kick voice loading on Edge
    try { window.speechSynthesis.getVoices(); } catch(_){}
    ensureLoaded(function(){ chosen = pickVi(); });
  } catch(e){ /* no-op */ }
})();
</script>

<script>
function pickVietnameseVoice() {
  const voices = speechSynthesis.getVoices();
  return voices.find(v => v.lang === "vi-VN")
      || voices.find(v => v.lang && v.lang.toLowerCase().includes("vi"))
      || null;
}
</script>
<style>
 
  
  
  /* Dùng 100dvh/100dvw; fallback dùng --vh nếu trình duyệt chưa hỗ trợ */
  #svgContainer{
    
    height: 100vh;
    width: 100vw;
    /* Fallback */
    
    padding: env(safe-area-inset-top, 0) env(safe-area-inset-right, 0)
             env(safe-area-inset-bottom, 0) env(safe-area-inset-left, 0);
    box-sizing: border-box;
  }
  #svgContainer:fullscreen, #svgContainer:-webkit-full-screen{
    height: 100vh !important;
    width:  100vw !important;
  }

#svgContainer svg {
  display: block;
  margin: auto;
  
  object-fit: contain;
}

 #svgContainer.blank {
  background: #fff;     /* nền trắng */
  outline: none;        /* bỏ outline */
}
#svgContainer.blank > * {
  display: none !important;  /* ẩn toàn bộ con (SVG, text...) */
}
  /* Ẩn scrollbar như NeboN */
  #svgContainer { scrollbar-width: none; -ms-overflow-style: none; }
  #svgContainer::-webkit-scrollbar { display: none; }

</style>

<style id="no_opp_2x_fix">
  /* Keep center + padding in no-opp-2x mode */
  #svgContainer.no-opp-2x {
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    padding: 5px !important;
    margin: 0 auto !important;
    box-sizing: border-box !important;
  }
</style>
<style>
/* Keep centering even in fullscreen */
#svgContainer:fullscreen,
#svgContainer:-webkit-full-screen {
  display: flex !important;
  justify-content: center !important;
  align-items: center !important;
  padding: 5px !important;
  margin: 0 auto !important;
  box-sizing: border-box !important;
}
#svgContainer:fullscreen svg,
#svgContainer:-webkit-full-screen svg {
  display: block;
  margin: auto;
  
  object-fit: contain;
}
</style>


<script id="scroll_anchor_helper">
(function(){
  function clamp01(x){ x=+x; return isFinite(x)?Math.max(0,Math.min(1,x)):0; }
  function getContainer(){ return document.getElementById('svgContainer') || document.querySelector('#svgContainer'); }
  window.__tryApplyScrollAnchor = function(ds, smooth){
    try{
      var c = getContainer();
      if(!c) return false;
      var sh = c.scrollHeight, ch = c.clientHeight;
      var sw = c.scrollWidth,  cw = c.clientWidth;
      // prefer vertical scroll; if no vertical range, try horizontal
      var hasY = (sh - ch) > 2;
      var hasX = (sw - cw) > 2;
      var k = clamp01(parseFloat(ds)/2); // 0->0, 1->0.5, 2->1
      if(hasY){
        var top = (sh - ch) * k;
        c.scrollTo({ top: top, behavior: smooth ? 'smooth':'auto' });
        return true;
      }
      if(hasX){
        var left = (sw - cw) * k;
        c.scrollTo({ left: left, behavior: smooth ? 'smooth':'auto' });
        return true;
      }
      return false;
    }catch(_){ return false; }
  };
})();
</script>

<style id="center_svg_patch">
/* Căn giữa SVG trong mọi trường hợp */
#svgContainer {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}

/* Khi ở chế độ NO + Opposite scroll */
#svgContainer.no-opp-2x {
  justify-content: center;
  align-items: center; /* nếu scroll dọc */
}
@media (orientation: landscape) {
  #svgContainer.no-opp-2x {
    align-items: center;
    justify-content: center; /* nếu scroll ngang */
  }
}
</style>

<style id="fs_center_patch">
/* --- FS + Opposite fix (có scroll, không lệch, căn giữa chuẩn) --- */

/* Khi fullscreen */
#svgContainer:fullscreen,
#svgContainer:-webkit-full-screen {
  display: flex !important;
  justify-content: center !important;
  align-items: center !important;
  width: 100vw !important;
  height: 100vh !important;
  margin: 0 !important;
  padding: 0 !important;
  box-sizing: border-box !important;
}

/* --- Chế độ Opposite (trái chiều xoay ngang/dọc) --- */
#svgContainer.opp-x,
#svgContainer.opp-y {
  display: flex !important;
  justify-content: center !important;
  align-items: center !important;
  width: 100vw !important;
  height: 100vh !important;
  margin: 0 auto !important;
  padding: 5px !important;
  box-sizing: border-box !important;
}

/* Cho phép cuộn đúng hướng mà vẫn giữ căn giữa */
#svgContainer.opp-x {
  overflow-x: auto !important;
  overflow-y: hidden !important;
}
#svgContainer.opp-y {
  overflow-y: auto !important;
  overflow-x: hidden !important;
}

/* SVG bên trong luôn căn giữa, không bị phóng lệch hoặc lồi */
#svgContainer.opp-x > svg,
#svgContainer.opp-y > svg {
  display: block;
  margin: auto;
  
  width: auto;
  height: auto;
  object-fit: contain;
}

/* Đảm bảo không flex lỗi khi cuộn */

#svgContainer > svg { 
  flex: 0 0 auto !important; 
}
</style>


<!-- FINAL PATCH: Hide all scrollbars globally and fix container -->
<style id="hide_scroll_global_final">
html, body {
  margin: 0;
  padding: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden; /* no scrollbar at all */
}

#svgContainer {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
  background: transparent;
  scrollbar-width: none;
  -ms-overflow-style: none;
}
#svgContainer::-webkit-scrollbar { display: none; }

#svgContainer svg {
  display: block;
  width: 100%;
  height: 100%;
  max-width: none !important;
  max-height: none !important;
  margin: auto;
}
</style>
<style id="scroll_anchor_overrides">
/* (patched) Allow scrolling when layout code sets opp-x/opp-y/no-opp-2x */
#svgContainer.ps-free.opp-y { overflow-y: auto !important; overflow-x: hidden !important; }
#svgContainer.ps-free.opp-x { overflow-x: auto !important; overflow-y: hidden !important; }
#svgContainer.ps-free.no-opp-2x { overflow-y: auto !important; overflow-x: hidden !important; }

/* If we need a scroll range for 2 pages, keep SVG taller in no-opp-2x mode */
#svgContainer.ps-free.no-opp-2x > svg { height: 200vh !important; width: auto !important; }
</style>


<style id="svg_image_dark_patch">
/* Light mode giữ nguyên */
svg image {
  image-rendering: optimizeQuality;
  filter: none;
}

/* Dark mode → invert hoàn toàn */
@media (prefers-color-scheme: dark) {
  svg image {
    filter: invert(1);
  }
}
</style>

</head>
<body>
  <!-- === GLOBAL SVG PATTERN BANK (paste right after <body>) === -->
<svg aria-hidden="true" width="0" height="0" style="position:absolute;left:-9999px;top:-9999px;overflow:hidden"><defs id="geoDefs">
    <pattern id="patR" patternUnits="userSpaceOnUse"
         width="4.8" height="4.8">
  <path d="M0.6 0.6 L 4.2 4.2"
      stroke="#808080" stroke-width="0.6" fill="none"/>
</pattern>
  
<pattern id="patL" patternUnits="userSpaceOnUse"
         width="4.8" height="4.8">
  <path d="M0.6 4.2 L 4.2 0.6"
      stroke="#808080" stroke-width="0.6" fill="none"/>
</pattern>

  

  <pattern id="patH" patternUnits="userSpaceOnUse"
           width="4.8" height="4.8">
    <path d="M0 2.4 H 4.8"
          fill="none" stroke="#808080" stroke-width="0.5" opacity="1"/>
  </pattern>
<pattern id="patV" patternUnits="userSpaceOnUse"
         width="4.8" height="4.8">
  <path d="M2.4 0  V4.8"
          fill="none" stroke="#808080" stroke-width="0.5" opacity="1"/>       
</pattern>
  
  
<pattern id="patD" patternUnits="userSpaceOnUse"
           width="4.8" height="4.8">
    <circle cx="2.4" cy="2.4" r="0.6" fill="#808080" opacity="1"/>
  </pattern>

  

  
</defs>
</svg>

  <audio id="bgMusic" src="music0.mp3" loop></audio>

<div id="wrapper">
<div id="svgContainer">Đang tải SVG…</div>
</div>
<script>
/* ==================== STATE (từ NeboC) ==================== */
let texttts = "", ttsSegments = [];
let waitingForClick = false;
let ttsSyncWait = false, svgSyncWait = false;

let utterance, ttsIsPlaying = false, svgIsPlaying = false;
let currentPart = 0, charIndex = 0;
let tl;
const bgMusic = document.getElementById("bgMusic");
if (typeof speechSynthesis !== 'undefined') speechSynthesis.onvoiceschanged = function(){ try{ console.log('Voices loaded', speechSynthesis.getVoices().map(v=>v.lang)); }catch(e){} };

// === NEW: manage delay + resume when waitingForClick ===
let pendingDelayTimer = null;


// === AUTO RESUME FOR [D0] / data-play="0" ===
let autoResumeTimer = null;
const AUTO_RESUME_DELAY = 15000; // 15s
/* removed duplicate function resumeAfterWait */

/* === Helpers: stop nhạc khi xong === */
function stopBgMusic(){
  if(bgMusic){
    try{ bgMusic.pause(); }catch(_){}
    try{ bgMusic.currentTime = 0; }catch(_){}
  }
}
function stopBgMusicIfAllDone(){
  if(!ttsIsPlaying && !svgIsPlaying){
    stopBgMusic();
  }
}

function triggerFinalEffect() {
  if (svgContainer.classList.contains("blank")) return;
  stopBgMusic(); // đảm bảo tắt nhạc lúc kết thúc
  setTimeout(() => {
    svgContainer.innerHTML = "";   // Xóa toàn bộ SVG
  }, 60000); // 60 giây
}

let firstUserGestureDone = false, wasPausedByVisibilityChange=false;
const svgContainer = document.getElementById("svgContainer");

/* ===== Visual cues (từ NeboC, hiệu chỉnh nền như NeboN) ===== */
function showManualPauseCue(){ 
  // User manual pause: show SOLID gray outline on the main toggle button (invertToggle)
  const mainBtn = document.getElementById('invertToggle');
  const noBtn = document.getElementById('noToggleBtn');

  // Keep noToggleBtn clean (it may be hidden)
  if (noBtn){
    noBtn.style.outline = "none";
    noBtn.style.outlineOffset = "0";
  }
  if (mainBtn){
    mainBtn.style.outline = "3px solid #808080";
    mainBtn.style.outlineOffset = "1px";
  }
  try{ window.__lockLayout && window.__lockLayout(false); }catch(_){ }

}


function showPauseCue(){ 
  const mode = (typeof waitingForClick !== 'undefined') ? waitingForClick : null;
  const mainBtn = document.getElementById('invertToggle');
  const noBtn = document.getElementById('noToggleBtn');

  // clear noToggleBtn (may be hidden)
  if (noBtn){
    noBtn.style.outline = "none";
    noBtn.style.outlineOffset = "0";
  }

  if (!mainBtn) return;

  if (mode === "both" || mode === "svg"){
    // System pause / wait: DASHED gray outline on main toggle button
    mainBtn.style.outline = "3px dashed #808080";
    mainBtn.style.outlineOffset = "1px";
  } else {
    // Other cases (including TTS-only wait): no outline here
    mainBtn.style.outline = "3px solid #808080";
    mainBtn.style.outlineOffset = "1px";
  }
  try{ window.__lockLayout && window.__lockLayout(false); }catch(_){ }

}


function showPlayCue(){

// (SNAP) When switching to PLAY, always snap to last scripted data-scroll anchor
try{
  if(window.__pendingScroll!=null){
    window.__tryApplyScrollAnchor && window.__tryApplyScrollAnchor(window.__pendingScroll, true);
  }
  try{ window.__lockLayout && window.__lockLayout(true); }catch(_){ }

}catch(_){} 
  const noBtn = document.getElementById('noToggleBtn');
  const invertBtn = document.getElementById('invertToggle');

  if (noBtn){
    noBtn.style.outline = "none";
    noBtn.style.outlineOffset = "0";
  }
  if (invertBtn){
    invertBtn.style.outline = "none";
    invertBtn.style.outlineOffset = "0";
  }
}


/* ==================== TTS (từ NeboC: tách [D] thành 2 loại) ==================== */
function ensureVoices(cb){
  let voices = speechSynthesis.getVoices();
  if (voices && voices.length) {
    cb && cb();
    return;
  }
  speechSynthesis.onvoiceschanged = () => {
    voices = speechSynthesis.getVoices();
    cb && cb();
  };
}

/* removed duplicate function processText */

function startBoth(){
    try { (document.getElementById('svgContainer')||svgContainer).style.outline = 'none'; } catch(_) {}
if(!ttsSegments.length) ttsSegments = processText(texttts||"");
  if(tl && !tl.isActive()) tl.play();
  // >>> Bổ sung nhạc nền
  if(bgMusic && bgMusic.src){
    bgMusic.currentTime = 0;
    bgMusic.play().catch(()=>{});
  }
  
  svgIsPlaying=true; showPlayCue();
  ensureVoices(()=>{ ttsIsPlaying=true; speakPart(); });
}

/* ==================== 2-CHANNEL SYNC PATCH ==================== */
let ttsPendingClick = false; 
let svgPendingClick = false;
function checkBothWaiting() {
  if (ttsPendingClick && svgPendingClick) {
    waitingForClick = true;
    try{ const c=document.getElementById('svgContainer'); if(c){ window.__pauseScrollPos={left:c.scrollLeft||0, top:c.scrollTop||0}; } }catch(_){ }
    svgIsPlaying = false;
    ttsIsPlaying = false;
    if (typeof showPauseCue === "function") showPauseCue();
  }
}
function ttsMeetHardStop() {
  ttsPendingClick = true;
  try { speechSynthesis.pause(); }catch(_){}
  checkBothWaiting();
}
function svgMeetHardStop() {
  svgPendingClick = true;
  if (tl && tl.pause) tl.pause();
  svgIsPlaying = false;
  checkBothWaiting();
}
function skipTtsD0AndContinue() { ttsPendingClick = false; }
function skipSvgD0AndContinue() { svgPendingClick = false; }
function clearAutoResume(){
  if (autoResumeTimer){
    clearTimeout(autoResumeTimer);
    autoResumeTimer = null;
  }
}

function scheduleAutoResume(){
  clearAutoResume();
  autoResumeTimer = setTimeout(()=>{
    if (waitingForClick === "both"){
      try{ resumeAfterWait(); }catch(_){ }
    }
  }, AUTO_RESUME_DELAY);
}

function resumeAfterWait() {
    // When resuming play, always snap back to the last scripted data-scroll anchor
    // (ignores any manual scroll the user did while paused)
    try{ window.__userScrollLock = false; }catch(_){}
    try{
      if(window.__pendingScroll!=null){
        window.__tryApplyScrollAnchor && window.__tryApplyScrollAnchor(window.__pendingScroll, true);
      }
    }catch(_){}
clearAutoResume();
waitingForClick = false;
  ttsPendingClick = false;
  svgPendingClick = false;
  try { if (window.speechSynthesis.paused) window.speechSynthesis.resume();
        else { ttsIsPlaying = true; speakPart(); } }catch(_){}
  try { if (tl && tl.paused()) tl.resume(); svgIsPlaying = true; }catch(_){}
  if (typeof showPlayCue === "function") showPlayCue();
}
/* ================== END SYNC PATCH ================== */

function togglePlay(){
  if(!firstUserGestureDone){ firstUserGestureDone=true; startBoth(); return; }

  // 1) Trạng thái chờ TTS ([D] → đợi data-play="0"): toggle chỉ điều khiển SVG
  if (ttsSyncWait){
    if(svgIsPlaying){
      // Đang chạy SVG → tạm dừng SVG
      try{
        if(bgMusic && !bgMusic.paused) bgMusic.pause();
        tl && tl.pause && tl.pause();
      }catch(e){}
      svgIsPlaying = false;
      try{ showManualPauseCue && showManualPauseCue(); }catch(e){}
    }else{
      // SVG đang dừng (do người dùng) → cho SVG chạy lại, TTS vẫn chờ
      try{
        if(bgMusic && bgMusic.paused && bgMusic.src) bgMusic.play().catch(()=>{});
        tl && tl.resume && tl.resume();
      }catch(e){}
      svgIsPlaying = true;
      try{ showPlayCue && showPlayCue(); }catch(e){}
    }
    return;
  }

  // 2) Trạng thái chờ SVG (data-play="" → đợi [D0]): toggle chỉ điều khiển TTS
  if (svgSyncWait){
    if(ttsIsPlaying){
      // Đang đọc TTS → tạm dừng
      try{ speechSynthesis.cancel(); }catch(e){}
      ttsIsPlaying = false;
      try{ showManualPauseCue && showManualPauseCue(); }catch(e){}
    }else{
      // TTS đang dừng (do người dùng) → đọc tiếp
      ttsIsPlaying = true;
      speakPart();
      try{ showPlayCue && showPlayCue(); }catch(e){}
    }
    return;
  }

  // 3) Trường hợp bình thường (không có cờ sync): xử lý như cũ
  // Handle click-to-continue (from [D0] / waitClick)
  if (waitingForClick) { resumeAfterWait(); return; }
  if(tl && tl.paused && tl.paused()){
    // NEW: luôn resume nhạc trước khi return
    if(bgMusic && bgMusic.paused && bgMusic.src){
      bgMusic.play().catch(()=>{});
    }
    tl.resume(); svgIsPlaying=true; showPlayCue(); try { if (window.speechSynthesis && window.speechSynthesis.paused) { window.speechSynthesis.resume(); } else if(!ttsIsPlaying){ ttsIsPlaying=true; speakPart(); } } catch(e){} if(!ttsIsPlaying){ ttsIsPlaying=true; speakPart(); }
    return;
  }
  // >>> Resume nhạc nếu đang pause
  if(bgMusic && bgMusic.paused && bgMusic.src){
    bgMusic.play().catch(()=>{});
  }
  if(svgIsPlaying || ttsIsPlaying){
    if(bgMusic && !bgMusic.paused){
      bgMusic.pause();
    }
    tl && tl.pause(); try{ speechSynthesis.cancel(); }catch(e){};
    svgIsPlaying=false; ttsIsPlaying=false; showManualPauseCue();
  }else{
    // NEW: bảo đảm nhạc chạy khi play lại
    if(bgMusic && bgMusic.paused && bgMusic.src){
      bgMusic.play().catch(()=>{});
    }
    startBoth();
  }
}

/* ==================== Auto-Pause khi blur/hidden (từ NeboC) ==================== */
function autoPause(reason) {
    clearAutoResume();
// Tạm dừng timeline + TTS
  try {
    if (tl && tl.isActive && tl.isActive() && !tl.paused()) tl.pause();
  } catch (e) {}

  try {
    speechSynthesis.cancel();
  } catch (e) {}

  // Cập nhật trạng thái
  svgIsPlaying = false;
  ttsIsPlaying = false;
  try { showManualPauseCue && showManualPauseCue(); } catch (e) {}

  // LUÔN tắt nhạc khi blur/hidden; không tự phát lại
  try {
    if (bgMusic) bgMusic.pause();
  } catch (e) {}
}

window.addEventListener('blur', ()=>{ autoPause('blur'); });
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){ autoPause('hidden');

// Bổ sung đảm bảo dừng nhạc khi trang bị ẩn/đóng (như neboH)
window.addEventListener('pagehide', ()=>{ autoPause('pagehide'); });
 }
});

/* ==================== Helpers lấy TTS từ SVG (từ NeboC) ==================== */
function extractTTSFromSVG(svg){
  const candidates = ['#tts-audio','[data-tts]','#ttsText','#tts','desc','title','[data-text]'];
  for(const sel of candidates){
    const el = svg.querySelector(sel);
    if(el){
      const candidate = el.getAttribute('data-text') || el.textContent || '';
      if(candidate && candidate.trim()) return candidate;
    }
  }
  try{ if(typeof texttts === 'string' && texttts.trim()) return texttts; }catch(e){}
  return '';
}

/* ==================== Timeline (N + C hợp nhất) ==================== */
function markDashed(svgElem){
  if(!svgElem) return;
  svgElem.querySelectorAll('path, line, polyline, polygon, rect, circle, ellipse').forEach(el=>{
    try{ const __r=(el.getAttribute('data-role') || (el.closest && el.closest('[data-role]') && el.closest('[data-role]').getAttribute('data-role')) || '').toLowerCase(); if(__r==='note') return; }catch(_){ }
    if(el.hasAttribute('data-type')) return;
    const strokeAttr = el.getAttribute('stroke') || window.getComputedStyle(el).stroke || '';
    const normStroke = (strokeAttr || '').replace(/\s+/g,'').toLowerCase();
    const blackList = ['black','#000','rgb(0,0,0)','rgba(0,0,0,1)'];
    const dashAttr = el.getAttribute('stroke-dasharray') || window.getComputedStyle(el).strokeDasharray;
    if(blackList.includes(normStroke) || (dashAttr && dashAttr !== 'none')){
      el.setAttribute('data-type','dash');
    }
  });
};

function getAttrOrStyle(el, name){
  let v = el.getAttribute(name);
  if(v && v.trim() && v.trim()!=='none') return v.trim();
  const styleAttr = el.getAttribute('style')||'';
  const m = styleAttr.match(new RegExp(name+'\\s*:\\s*([^;]+)','i'));
  if(m && m[1].trim() && m[1].trim()!=='none') return m[1].trim();
  const cs = window.getComputedStyle(el);
  const val = cs[name];
  if(val && val.trim() && val.trim()!=='none') return val.trim();
  return '';
}


function normalizeGrayStrokeWidth(svg){
  try{
    svg.querySelectorAll('path,line,polyline,polygon').forEach(el=>{
      try{ const __r=(el.getAttribute('data-role') || (el.closest && el.closest('[data-role]') && el.closest('[data-role]').getAttribute('data-role')) || '').toLowerCase(); if(__r==='note') return; }catch(_){ }
      try{
        const cs = window.getComputedStyle(el);
        const stroke = (el.getAttribute('stroke') || cs.stroke || '').trim().toLowerCase();
        if(!stroke) return;
        const isGray = (stroke === '#808080' ||
                        stroke === 'rgb(128, 128, 128)' ||
                        stroke === 'rgba(128, 128, 128, 1)');
        if(!isGray) return;
        let swRaw = el.getAttribute('stroke-width') || cs.strokeWidth || '0.5';
        let sw = parseFloat(swRaw);
      el.style.strokeWidth = String((isFinite(sw0) ||sw0 > 0) ? sw0*0.5:0.5);

     

        el.setAttribute('stroke-width', String(sw));
        el.style.strokeWidth = String(sw);
      }catch(_){}
    });
  }catch(_){}
}


function getBrightnessFromFill(el){
  try{
    const cs   = window.getComputedStyle(el);
    let fill = (el.getAttribute('fill') || cs.fill || '').trim().toLowerCase();
    if (!fill || fill === 'none') return null;

    let r, g, b;

    if (fill.startsWith('rgb')) {
      const m = fill.match(/^rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
      if (!m) return null;
      r = parseInt(m[1], 10);
      g = parseInt(m[2], 10);
      b = parseInt(m[3], 10);
    } else if (fill[0] === '#') {
      let hex = fill.slice(1);
      if (hex.length === 3) {
        hex = hex.split('').map(ch => ch + ch).join('');
      }
      if (hex.length !== 6) return null;
      const num = parseInt(hex, 16);
      if (!isFinite(num)) return null;
      r = (num >> 16) & 255;
      g = (num >> 8) & 255;
      b =  num        & 255;
    } else {
      return null;
    }

    const maxC = Math.max(r, g, b);
    return maxC / 255; // 0 → 1
  } catch (_) {
    return null;
  }
}


// --- Static black strokes: show from the beginning, no draw animation ---
function isStaticBlackStroke(el){
  if (!el || !el.tagName) return false;
  const tag = el.tagName.toLowerCase();
  if (tag !== 'path' && tag !== 'line' && tag !== 'polyline' && tag !== 'polygon') return false;
  try{
    const strokeAttr = el.getAttribute('stroke') || '';
    const cs = window.getComputedStyle ? window.getComputedStyle(el) : null;
    const stroke = (strokeAttr || (cs && cs.stroke) || '').trim().toLowerCase();
    if (!stroke || stroke === 'none') return false;
    const s = stroke.replace(/\s+/g,'');
    const blackList = ['black','#000','rgb(0,0,0)','rgba(0,0,0,1)'];
    return blackList.includes(s);
  }catch(e){
    return false;
  }
}


/* ==================== PARAM FIG ENGINE (Neboz) ====================
   - SVG là “kịch bản”: dùng <text style="display:none"> làm marker.
   - Engine chỉ đọc data-fig / data-at / data-start / data-end / data-dur / data-wait
   - Hình phụ thuộc tham số: template có data-fig + (data-count / data-set)
   - Chỉ 1 cơ chế lặp: for i = 1..count, với biến n,i,t (t:0..1 tùy chọn)
=================================================================== */
let __param = {
  svg: null,
  figTemplates: new Map(),  // fig -> [template elements]
  pinnedForever: new Set(), // fig names pinned until explicitly unpinned
  pinTimers: new Map(),     // fig -> gsap delayedCall
};

function __paramInit(svg){
  try{
    __param.svg = svg;
    __param.figTemplates = new Map();
    try{ __param.pinnedForever = new Set(); }catch(_){ __param.pinnedForever = new Set(); }
    try{ __param.pinTimers = new Map(); }catch(_){ __param.pinTimers = new Map(); }

    // Template: bất kỳ node nào có data-fig và (data-set hoặc data-count)
    // (loại trừ marker <text> có data-at/data-start...)
    const temps = Array.from(svg.querySelectorAll('[data-fig][data-set], [data-fig][data-count]'));
    temps.forEach(el=>{
      const tag = (el.tagName||'').toLowerCase();
      if(tag === 'text' && (el.hasAttribute('data-at') || el.hasAttribute('data-start') || el.hasAttribute('data-end'))) return;

      const fig = (el.getAttribute('data-fig')||'').trim();
      if(!fig) return;

      if(!__param.figTemplates.has(fig)) __param.figTemplates.set(fig, []);
      __param.figTemplates.get(fig).push(el);

      // đánh dấu + ẩn template để không phá reveal sẵn có
      try{ el.setAttribute('data-template','1'); }catch(_){}
      try{ el.style.display = 'none'; }catch(_){}
      try{ el.style.opacity = '0'; }catch(_){}
    });
  }catch(_){}
}

function __evalExpr(expr, n, i, t){
  try{
    // Cho phép dùng Math.*
    // expr được viết dạng JS: ví dụ "n", "i*10", "210+20*i", "Math.sin(i)"
    const fn = new Function('n','i','t','Math', 'return (' + expr + ');');
    return fn(n,i,t,Math);
  }catch(_){
    return null;
  }
}


function __parseNumList(s){
  try{
    if(s==null) return null;
    s = String(s).trim();
    if(!s) return null;

    // JSON array: [1,2,3]
    if(s[0]==='['){
      try{
        const arr = JSON.parse(s);
        if(Array.isArray(arr)){
          const out = arr.map(v=>Number(v)).filter(v=>isFinite(v));
          return out.length ? out : null;
        }
      }catch(_){}
    }

    const toks = s.split(/[\s,;]+/).map(t=>t.trim()).filter(Boolean);
    const out = [];
    toks.forEach(t=>{
      // range support: a..b or a-b
      let mm = t.match(/^(-?\d+(?:\.\d+)?)\.{2}(-?\d+(?:\.\d+)?)$/);
      if(!mm) mm = t.match(/^(-?\d+(?:\.\d+)?)-(-?\d+(?:\.\d+)?)$/);
      if(mm){
        const a = Number(mm[1]), b = Number(mm[2]);
        if(isFinite(a) && isFinite(b)){
          const step = (b>=a) ? 1 : -1;
          for(let v=a; step>0 ? v<=b : v>=b; v+=step) out.push(v);
          return;
        }
      }
      const v = Number(t);
      if(isFinite(v)) out.push(v);
    });
    return out.length ? out : null;
  }catch(_){
    return null;
  }
}




function __applySet(el, setStr, n, i, t){
  if(!setStr) return;
  const stmts = String(setStr).split(';').map(s=>s.trim()).filter(Boolean);
  stmts.forEach(st=>{
    const k = st.indexOf('=');
    if(k < 0) return;
    const lhs = st.slice(0,k).trim();
    const rhs = st.slice(k+1).trim();
    const v = __evalExpr(rhs, n, i, t);
    if(v === null || v === undefined) return;

    if(lhs === 'text' || lhs === 'textContent'){
      try{ el.textContent = String(v); }catch(_){}
      return;
    }
    if(lhs.startsWith('style.')){
      const prop = lhs.slice(6).trim();
      try{ el.style[prop] = String(v); }catch(_){}
      return;
    }
    try{ el.setAttribute(lhs, String(v)); }catch(_){}
  });
}

function __clearFig(fig){
  const svg = __param.svg;
  if(!svg) return;
  try{
    Array.from(svg.querySelectorAll('[data-gen="1"]')).forEach(node=>{
      if((node.getAttribute('data-fig')||'') === fig) node.remove();
    });
  }catch(_){}
}

function __renderFig(fig, n, t){
  const svg = __param.svg;
  if(!svg) return;
  const temps = __param.figTemplates.get(fig);
  if(!temps || !temps.length) return;

  __clearFig(fig);

  temps.forEach(temp=>{
    const parent = temp.parentNode;
    if(!parent) return;

    const countExpr = (temp.getAttribute('data-count') || '1').trim();
    let countVal = __evalExpr(countExpr, n, 1, t);
    if(countVal === null){
      countVal = parseFloat(countExpr);
    }
    let cnt = Math.floor(Number(countVal));
    if(!isFinite(cnt)) cnt = 0;
    cnt = Math.max(0, cnt);

    let insertAfter = temp;
    for(let i=1;i<=cnt;i++){
      const clone = temp.cloneNode(true);
      clone.removeAttribute('data-template');
      clone.setAttribute('data-gen','1');
      clone.setAttribute('data-fig', fig);

      // show clone
      try{ clone.style.display = ''; }catch(_){}
      try{ clone.style.opacity = ''; }catch(_){}

      // áp data-set
      __applySet(clone, temp.getAttribute('data-set')||'', n, i, t);

      // chèn ngay sau template / sau clone trước đó, để giữ trật tự DOM
      try{ parent.insertBefore(clone, insertAfter.nextSibling); }catch(_){ try{ parent.appendChild(clone); }catch(__){} }
      insertAfter = clone;
    }
  });
}

function __showFig(fig, n, t){
  __renderFig(fig, n, t);
}

function __hideFig(fig){
  // nếu fig đang pin vô thời hạn thì không tự clear
  try{
    if(__param && __param.pinnedForever && __param.pinnedForever.has(fig)) return;
  }catch(_){}
  __clearFig(fig);
}

function __hideFigForce(fig){
  // clear bất kể pin
  try{
    if(__param && __param.pinnedForever) __param.pinnedForever.delete(fig);
  }catch(_){}
  __clearFig(fig);
}

function __pinFig(fig, seconds){
  // hủy timer cũ nếu có
  try{
    const old = __param.pinTimers && __param.pinTimers.get(fig);
    if(old && old.kill) old.kill();
    if(__param.pinTimers) __param.pinTimers.delete(fig);
  }catch(_){}
  // pin vô thời hạn
  if(seconds === null){
    try{ __param.pinnedForever.add(fig); }catch(_){}
    return;
  }
  // pin theo số giây (không chặn timeline)
  try{
    const s = Math.max(0, seconds || 0);
    if(s > 0 && window.gsap && gsap.delayedCall){
      const dc = gsap.delayedCall(s, ()=>{ try{ __hideFigForce(fig); }catch(_){} });
      __param.pinTimers.set(fig, dc);
    }
  }catch(_){}
}

function __unpinFig(fig){
  try{ __param.pinnedForever.delete(fig); }catch(_){}
  try{
    const old = __param.pinTimers && __param.pinTimers.get(fig);
    if(old && old.kill) old.kill();
    if(__param.pinTimers) __param.pinTimers.delete(fig);
  }catch(_){}
  try{ __clearFig(fig); }catch(_){}
}

/* ==================== END PARAM FIG ENGINE ==================== */

function buildTimeline(svg){
  tl = gsap.timeline({paused:true});
  // DATA-FILL addon: ensure pattern overlays exist before timeline is built
  try{ if(window.__applyDataFill) window.__applyDataFill(svg); }catch(_){ }
  
  try{ __paramInit(svg); }catch(_){ }
normalizeGrayStrokeWidth(svg);
  // Bỏ viền cho tất cả rect và ellipse (không vẽ outline)
  try{
    svg.querySelectorAll('rect, ellipse').forEach(el=>{
      el.setAttribute('stroke','none');
      el.style.stroke = 'none';
      el.setAttribute('stroke-width','0');
      el.style.strokeWidth = '0';
    });
  }catch(_){}

  let currentDelay=0;

  // gán data-type mặc định như NeboN
  svg.querySelectorAll('path, line, polyline, polygon, rect, circle, ellipse').forEach(el=>{
    if(el.hasAttribute('data-type')) return;
    const dashAttr = el.getAttribute('stroke-dasharray');
    const isDashed = dashAttr && dashAttr.trim() !== 'none';
    if(isDashed) el.setAttribute('data-type','dash');
  });
  
  /* DISABLED: auto-detect highlights based on alpha 0.3-0.5
// ==== AUTO-DETECT HIGHLIGHTS (open path, semi-transparent fill ~0.3-0.5 alpha, no stroke) ====
  svg.querySelectorAll('path').forEach(el=>{
    try{
      if(el.hasAttribute('data-type')) return;
      const d = (el.getAttribute('d')||'').trim();
      const isClosedZ = /[zZ]\s*$/.test(d);
      const fill = getAttrOrStyle(el, 'fill') || '';
      const stroke = getAttrOrStyle(el, 'stroke') || '';
      const semi = /rgba?\(/i.test(fill) && /[, ]0\.(3|4|5)\b/.test(fill);
      if(!isClosedZ && semi && (!stroke || /^none$/i.test(stroke))){
        el.setAttribute('data-type','highlight');
        // Normalize rgba; non-black -> white (eraser), alpha=0.4
        const normalized = fill.replace(/rgba?\(([^)]+)\)/i,(m,g)=>{
          let parts = g.split(',').map(s=>s.trim()).filter(Boolean);
          let r = parseFloat(parts[0]||'0'), g1 = parseFloat(parts[1]||'0'), b = parseFloat(parts[2]||'0');
          const nearBlack = (isFinite(r)&&isFinite(g1)&&isFinite(b) && (r<16 && g1<16 && b<16));
          if(!nearBlack){ r=255; g1=255; b=255; }
          return 'rgba(' + [Math.round(r),Math.round(g1),Math.round(b),'0.4'].join(',') + ')';
        });
        if(normalized) el.setAttribute('fill', normalized);
        el.setAttribute('stroke', 'none');
      }
    }catch(_){}
  });

  
*/
// === Move white (eraser) highlights to top so they draw above strokes ===
  (function raiseEraserHighlightsToTop(svg){
  try{
    // NO-OP: per-parent hue ordering handles z-order; keep structure intact.
  }catch(_){}
})(svg);

// === Raise elements only when overlapping with highlight (auto) ===
(function liftOnOverlap(svg){
  try{
    // NO-OP: per-parent hue ordering handles z-order; avoid DOM reshuffles here.
  }catch(_){}
})(svg);

svg.querySelectorAll('path, line, polyline, polygon').forEach(el=>{
    if(el.hasAttribute('data-type')) return;
    const computed = window.getComputedStyle(el);
    const stroke = el.getAttribute('stroke') || computed.stroke || '';
    const fill   = el.getAttribute('fill')   || computed.fill   || '';
    const norm = c => c ? c.replace(/\s+/g,'').toLowerCase() : '';
    const strokeColor = norm(stroke), fillColor = norm(fill);
    const black = ['black','#000','rgb(0,0,0)','rgba(0,0,0,1)'];
    const isBlackStroke = black.includes(strokeColor);
    const isBlackFill = black.includes(fillColor);
    const hasNoStroke = !stroke || stroke==='none' || strokeColor.includes('rgba(0,0,0,0)');
    if(isBlackStroke || (hasNoStroke && isBlackFill)){
      el.setAttribute('data-type','dash');
    }
  });
  // Phân loại riêng cho rect theo độ sáng fill
  svg.querySelectorAll('rect').forEach(el=>{
    if (el.hasAttribute('data-type')) return;
    const b = getBrightnessFromFill(el);
    if (b != null) {
      const p = b * 100;
      if (p < 15 || p > 85) {
        // rất tối hoặc rất sáng → eraser trắng, 0 → 1
        el.setAttribute('data-type', 'eraser');
      } else if (p > 45 && p < 55) {
        // quanh 50% → mask trắng, 1 → 0
        el.setAttribute('data-type', 'mask');
      } else {
        // còn lại → giữ logic xám như cũ
        el.setAttribute('data-type', 'rect-grey');
      }
    } else {
      // không đọc được màu → mặc định xám
      el.setAttribute('data-type', 'rect-grey');
    }
  });

  // Các shape còn lại giữ kiểu fill cũ
  svg.querySelectorAll('circle, ellipse, image').forEach(el=>{
    if (!el.hasAttribute('data-type')) el.setAttribute('data-type', 'fill');
  });

  // ==== Ưu tiên theo data-hue trước, rồi theo thứ tự DOM ====
  // TÁCH riêng danh sách gốc để giữ được thứ tự DOM ban đầu,
  // sau đó sort nhưng luôn ưu tiên path/shape trước, rect/ellipse sau trong cùng 1 hue.
  const allForTimeline = Array.from(svg.querySelectorAll(
    'path, line, polyline, rect, circle, ellipse, polygon, text, tspan, image'
  ));

  // Nếu <text> có chứa <tspan> thì coi mỗi <tspan> là 1 "element" riêng trong timeline,
  // và BỎ qua chính <text> để tránh lỗi: text chạy hết rồi mới tới path.
  let elements = allForTimeline.filter(el => {
    const tag = (el.tagName || '').toLowerCase();
    if (tag === 'text') {
      try { return !el.querySelector('tspan'); } catch (_) { return true; }
    }
    return true;
  });

  function __hueFor(el){
    const tag = (el.tagName || '').toLowerCase();

    // Ưu tiên data-hue ở chính <tspan>
    if (tag === 'tspan') {
      const v = parseFloat((el.getAttribute('data-hue') || '').trim());
      return Number.isFinite(v) ? v : 0;
    }

    // Với <text> (không có tspan): dùng data-hue của text
    if (tag === 'text') {
      const v = parseFloat((el.getAttribute('data-hue') || '').trim());
      return Number.isFinite(v) ? v : 0;
    }

    const v = parseFloat((el.getAttribute('data-hue') || '').trim());
    return Number.isFinite(v) ? v : 0;
  }

  elements.sort((a, b) => {
    let ha = __hueFor(a);
    let hb = __hueFor(b);
    if (ha !== hb) return ha - hb;

    const tagA = (a.tagName || '').toLowerCase();
    const tagB = (b.tagName || '').toLowerCase();
    const aIsRect = (tagA === 'rect' || tagA === 'ellipse') ? 1 : 0;
    const bIsRect = (tagB === 'rect' || tagB === 'ellipse') ? 1 : 0;
    if (aIsRect !== bIsRect) return aIsRect - bIsRect; // non-rect trước, rect/ellipse sau trong cùng 1 hue

    // Giữ thứ tự DOM để đảm bảo: text1, path, text2 (cùng hue) vẫn ra đúng
    return allForTimeline.indexOf(a) - allForTimeline.indexOf(b);
  });

  // Xử lý từng phần tử
  elements.forEach(el=>{


    // ===== PATCH: HARD SKIP STATIC (match old NeboLp behavior) =====
    try {
      const typeRaw = (el.getAttribute('data-type') || '').toLowerCase();
      const types = typeRaw.split(/\s+/).filter(Boolean);

      const isDashStaticSelf = (typeRaw === 'dashstatic');
      const isStaticSelf = types.includes('static') || isDashStaticSelf;

      let isStaticAncestor = false;
      let isDashStaticAncestor = false;
      let p = el.parentNode;
      while (p && p.getAttribute) {
        const t = (p.getAttribute('data-type') || '').toLowerCase();
        const tt = t.split(/\s+/).filter(Boolean);
        if (t === 'dashstatic') { isDashStaticAncestor = true; isStaticAncestor = true; break; }
        if (tt.includes('static')) { isStaticAncestor = true; break; }
        p = p.parentNode;
      }

      if (isStaticSelf || isStaticAncestor) {
        // hiện ngay, KHÔNG tham gia handwriting/timeline
        try {
          el.style.opacity = 1;
          if(isDashStaticSelf || isDashStaticAncestor){
            if(!el.getAttribute('stroke-dasharray')) el.setAttribute('stroke-dasharray','6 4');
            el.style.strokeDasharray = el.getAttribute('stroke-dasharray') || '6 4';
            el.style.strokeDashoffset = '0';
          }else{
            el.style.strokeDasharray = 'none';
            el.style.strokeDashoffset = '';
          }
        } catch (_) {}
        return; // <<< quan trọng: cắt khỏi mọi nhánh animate
      }
    } catch (_) {}
    // ===== END PATCH =====

    /* === PARAM MARKERS + TEMPLATE SKIP (Neboz) === */
    try{
      // Skip template nodes from reveal timeline
      if (el && el.getAttribute && el.getAttribute('data-template') === '1'){
        try{ el.style.display = 'none'; el.style.opacity = '0'; }catch(_){}
        return;
      }

      const __tag = (el.tagName||'').toLowerCase();

      // Marker điều khiển timeline: <text style="display:none" ...>
      if (__tag === 'text' && el.getAttribute && (
            el.hasAttribute('data-at') ||
            el.hasAttribute('data-start') ||
            el.hasAttribute('data-end')
          )) {

        const fig = (el.getAttribute('data-fig') || '').trim();
        // ẩn marker để không render chữ
        try{ el.style.display = 'none'; el.style.opacity = '0'; }catch(_){ }

        // optional: unpin figs trước khi chạy marker này
        try{
          const unpin = (el.getAttribute('data-unpin')||'').trim();
          if(unpin){
            unpin.split(/\s*,\s*/).filter(Boolean).forEach(f=>{ try{ __unpinFig(f); }catch(_){} });
          }
        }catch(_){ }


        // data-list="1,3,5" (hoặc "[1,3,5]" hoặc "1..5"): chạy theo danh sách giá trị n
        if (el.hasAttribute('data-list')) {
          const listRaw = (el.getAttribute('data-list') || '').trim();
          const list = __parseNumList(listRaw);
          if(list && list.length){
            const dur = Math.max(0, parseFloat(el.getAttribute('data-dur') || '0') || 0);
            const wait = Math.max(0, parseFloat(el.getAttribute('data-wait') || '0') || 0);

            // delay trước khi chạy marker này (nếu có)
            if (currentDelay > 0) {
              try{ tl.to({}, { duration: currentDelay }); }catch(_){}
            }

            if(dur > 0){
              // quét đều chỉ số danh sách trong dur giây
              const st = { k: 0 };
              const kMax = Math.max(0, list.length - 1);

              // show ngay giá trị đầu
              try{ __showFig(fig, list[0], 0); }catch(_){}

              tl.to(st, {
                k: kMax,
                duration: dur,
                ease: 'none',
                onUpdate: () => {
                  const idx = Math.max(0, Math.min(kMax, Math.floor(st.k + 1e-6)));
                  const nNow = list[idx];
                  const tNow = (kMax > 0) ? (idx / kMax) : 1;
                  try{ __showFig(fig, nNow, tNow); }catch(_){}
                }
              });

              // kết thúc: ẩn fig (trừ khi pin)
              const hasPinL = el.hasAttribute('data-pin');
              const pinRawL = hasPinL ? (el.getAttribute('data-pin')||'') : '';
              let pinSecondsL = null; // null = pin forever
              if(hasPinL){
                const s = String(pinRawL).trim();
                if(s !== ''){
                  const v = parseFloat(s);
                  if(isFinite(v) && v > 0) pinSecondsL = v;
                  else pinSecondsL = null;
                }else{
                  pinSecondsL = null;
                }
              }
              tl.call(()=>{
                try{
                  if(hasPinL) __pinFig(fig, pinSecondsL);
                  else __hideFig(fig);
                }catch(_){}
              });

              currentDelay = 0;
              return;
            }else{
              // không có dur: nếu có wait thì chia đều mỗi phần tử
              if(wait > 0){
                const step = wait / list.length;
                list.forEach((val, idx)=>{
                  tl.call(()=>{ try{ __showFig(fig, val, (list.length>1? idx/(list.length-1):1)); }catch(_){} });
                  tl.to({}, { duration: step });
                });

                const hasPinL2 = el.hasAttribute('data-pin');
                const pinRawL2 = hasPinL2 ? (el.getAttribute('data-pin')||'') : '';
                let pinSecondsL2 = null;
                if(hasPinL2){
                  const s = String(pinRawL2).trim();
                  if(s !== ''){
                    const v = parseFloat(s);
                    if(isFinite(v) && v > 0) pinSecondsL2 = v;
                    else pinSecondsL2 = null;
                  }else{
                    pinSecondsL2 = null;
                  }
                }

                tl.call(()=>{
                  try{
                    if(hasPinL2) __pinFig(fig, pinSecondsL2);
                    else __hideFig(fig);
                  }catch(_){}
                });

                currentDelay = 0;
                return;
              }else{
                // list nhưng không dur/wait: show 1 lần (momentary)
                try{ __showFig(fig, list[0], 0); }catch(_){}
                tl.call(()=>{ try{ __hideFig(fig); }catch(_){} });
                currentDelay = 0;
                return;
              }
            }
          }
        }

        // data-at="K" data-wait="s"
        if (el.hasAttribute('data-at')) {
          const K = parseFloat(el.getAttribute('data-at') || '0');
          const wait = Math.max(0, parseFloat(el.getAttribute('data-wait') || '0') || 0);

          // data-pin: nếu có -> KHÔNG chặn timeline; fig sẽ được giữ lại theo thời gian pin hoặc pin vô thời hạn
          const hasPin = el.hasAttribute('data-pin');
          const pinRaw = hasPin ? (el.getAttribute('data-pin')||'') : '';
          let pinSeconds = null; // null = pin forever
          if(hasPin){
            const s = String(pinRaw).trim();
            if(s !== ''){
              const v = parseFloat(s);
              if(isFinite(v) && v > 0) pinSeconds = v;
              else pinSeconds = null;
            }else{
              pinSeconds = null;
            }
          }

          tl.call(()=>{
            try{ __showFig(fig, K, 0); }catch(_){}
            if(hasPin){
              try{ __pinFig(fig, pinSeconds); }catch(_){}
            }
          }, null, '+=' + currentDelay);
          currentDelay = 0;

          if(hasPin){
            // không chặn timeline, không auto-hide theo wait
            return;
          }

          if (wait > 0){
            tl.to({}, { duration: wait });
          }

          // data-pin sau sweep: nếu có -> giữ fig thêm (không auto-hide ngay)
          const hasPin2 = el.hasAttribute('data-pin');
          const pinRaw2 = hasPin2 ? (el.getAttribute('data-pin')||'') : '';
          let pinSeconds2 = null; // null = pin forever
          if(hasPin2){
            const s2 = String(pinRaw2).trim();
            if(s2 !== ''){
              const v2 = parseFloat(s2);
              if(isFinite(v2) && v2 > 0) pinSeconds2 = v2;
              else pinSeconds2 = null;
            }else{
              pinSeconds2 = null;
            }
          }

          tl.call(()=>{
            try{
              if(hasPin2){
                __pinFig(fig, pinSeconds2);
              }else{
                __hideFig(fig);
              }
            }catch(_){}
          });
          currentDelay = 0;
          return;
        }

        // data-start="a" data-end="b" data-dur="T"
        const aRaw = el.getAttribute('data-start');
        const bRaw = el.getAttribute('data-end');
        const dur = Math.max(0, parseFloat(el.getAttribute('data-dur') || '0') || 0);

        if (aRaw !== null && bRaw !== null && dur > 0){
          const a = parseFloat(aRaw || '0');
          const b = parseFloat(bRaw || '0');
          const st = { v: a };

          tl.call(()=>{
            try{ __showFig(fig, a, 0); }catch(_){}
          }, null, '+=' + currentDelay);
          currentDelay = 0;

          tl.to(st, {
            v: b,
            duration: dur,
            ease: 'none',
            onUpdate: () => {
              const nNow = st.v;
              const tNow = (b !== a) ? ((nNow - a) / (b - a)) : 1;
              try{ __showFig(fig, nNow, Math.max(0, Math.min(1, tNow))); }catch(_){}
            }
          });

          tl.call(()=>{
            try{ __hideFig(fig); }catch(_){}
          });
          currentDelay = 0;
          return;
        }

        // Marker không hợp lệ → bỏ qua
        return;
      }
    }catch(_){}
    /* === END PARAM MARKERS + TEMPLATE SKIP === */

    // NEW: static strokes → always visible, no animation (so rect/mask can cover them by hue)
    const tag = (el.tagName || '').toLowerCase();
    let rawType = (el.getAttribute('data-type') || '').toLowerCase();
    let type = rawType; // giữ biến type cho các logic cũ (dash, rect, highlight...)
    let typeNoSpace = rawType.replace(/\s+/g, '');
    let typeTokens = rawType.split(/\s+/).filter(Boolean);

    // === NOTE role (data-role="note"): treat as handwriting content (gray), not dash/highlight ===
    let __role = '';
    try{ __role = (el.getAttribute('data-role') || (el.closest && el.closest('[data-role]') && el.closest('[data-role]').getAttribute('data-role')) || '').toLowerCase(); }catch(_){ __role=''; }
    // Normalize: WRITE elements tagged data-type~="grey" should behave like data-role="note"
    try{
      if(!__role){
        const __dt = ((el.getAttribute('data-type') || (el.closest && el.closest('[data-type]') && el.closest('[data-type]').getAttribute('data-type')) || '') + '').toLowerCase();
        const __isGreyType = __dt.split(/\s+/).includes('grey');
        const __tag = (el.tagName || '').toLowerCase();
        if(__isGreyType && (__tag === 'text' || __tag === 'tspan' || __tag === 'path')){
          __role = 'note';
        }
      }
    }catch(_){}
if(__role === 'note'){
      const __tag = (el.tagName || '').toLowerCase();
      // WRITE/HANDWRITE in this system is fill-based (not stroke-based)
      const __fillAttr = (el.getAttribute('fill') || '').trim().toLowerCase();
      const __style = (el.getAttribute('style') || '').toLowerCase();
      const __hasFill = (__fillAttr && __fillAttr !== 'none') || (/fill\s*:\s*[^;]+/i.test(__style) && !/fill\s*:\s*none/i.test(__style));
      const __isFillWrite = (__tag === 'text' || __tag === 'tspan') || (__tag === 'path' && __hasFill);

      if(__isFillWrite){
        // Fill-based write: grey via fill, remove stroke to avoid double-color artifacts
        try{ el.removeAttribute('stroke'); }catch(_){ }
        try{ el.style.removeProperty && el.style.removeProperty('stroke'); }catch(_){ }
        try{ el.setAttribute('stroke','none'); }catch(_){ }
        try{ el.style.setProperty('stroke','none','important'); }catch(_){ }
      }else{
        // Stroke-based note path: grey via stroke, keep fill none
        try{ el.setAttribute('stroke', '#808080'); }catch(_){ }
        try{ el.style.setProperty('stroke', '#808080', 'important'); }catch(_){ }
        try{ el.setAttribute('fill','none'); }catch(_){ }
        try{ el.style.setProperty('fill','none','important'); }catch(_){ }
      }

      // Ensure not dashed when acting as "note"
      try{ el.removeAttribute('stroke-dasharray'); }catch(_){ }
      try{ el.style.strokeDasharray = 'none'; }catch(_){ }

      // Force non-dash processing path in this renderer
      type = '';
      typeNoSpace = '';
      typeTokens = [];
    }

    // NEW: nếu là <text> mà data-type lại nằm trong <tspan> bên trong
    // thì mượn luôn data-type của tspan đầu tiên để xác định static/dashstatic.
    if (!rawType && tag === 'text') {
      const tspanWithType = el.querySelector('tspan[data-type]');
      if (tspanWithType) {
        rawType = (tspanWithType.getAttribute('data-type') || '').toLowerCase();
        type = rawType;
        typeNoSpace = rawType.replace(/\s+/g, '');
        typeTokens = rawType.split(/\s+/).filter(Boolean);
      }
    }

    // Kiểm tra static:
    //  - Có token 'static' trong data-type, hoặc
    //  - data-type='dashstatic', hoặc
    //  - nét đen tuyệt đối do Nebo tự nhận
    let isStatic = false;
    if (typeTokens.includes('static') || typeNoSpace === 'dashstatic' || isStaticBlackStroke(el)) {
      isStatic = true;
    }

    if (isStatic) {
      try{
        // Nếu là dashstatic → luôn là nét đứt 10 5, giữ pattern, chỉ bỏ offset
        if (typeNoSpace === 'dashstatic' &&
            (tag === 'path' || tag === 'line' || tag === 'polyline' || tag === 'polygon')) {
          el.setAttribute('stroke-dasharray', '6 4');
        }

        // NEW: static vẫn phải tôn trọng data-hue (ẩn trước, hiện đúng bước)
        // - Nếu có data-hue trên chính el (hoặc đã copy từ group) → hide ban đầu rồi tl.set hiện lại
        const __hueAttr = el.getAttribute('data-hue');
        const __hasHue = (__hueAttr != null && String(__hueAttr).trim() !== '');

        // Không xoá dasharray để các nét đứt tĩnh vẫn đứt; chỉ xoá offset nếu có
        el.removeAttribute('stroke-dashoffset');
        el.style.strokeDashoffset = null;

        if (__hasHue) {
          // Ẩn ban đầu, xuất hiện đúng thứ tự timeline (đã sort theo data-hue)
          el.style.opacity = 0;
          try{ tl.set(el, { opacity: 1 }, '+=' + currentDelay); }catch(_){ el.style.opacity = 1; }

          // AUTO-REVEAL cho surface: vì surface là "họ đường" (nhiều path) nên không vẽ nét được.
          // Ta tự tạo 1 rect phủ (màu nền) và "kéo" rect xuống để lộ surface dần.
          try{
            const bt = (el.getAttribute('data-bank-type')||'').trim().toLowerCase();
            const wantWipe = (bt === 'surface') && (String(el.getAttribute('data-reveal')||'off').toLowerCase() === 'on');
            if(wantWipe && (el.tagName||'').toLowerCase() === 'g'){
              if(!el.__autoSurfaceCover){
                // bbox trước khi thêm cover
                let bb = null;
                try{ bb = el.getBBox(); }catch(_){ bb = null; }
                if(bb && bb.width>0 && bb.height>0){
                  const r = document.createElementNS(NS,'rect');
                  r.setAttribute('x', bb.x);
                  r.setAttribute('y', bb.y);
                  r.setAttribute('width', bb.width);
                  r.setAttribute('height', bb.height);
                  // store bbox for robust (non-transform) reveal animation
                  r.setAttribute('data-bbx', String(bb.x));
                  r.setAttribute('data-bby', String(bb.y));
                  r.setAttribute('data-bbw', String(bb.width));
                  r.setAttribute('data-bbh', String(bb.height));
                  // cover fill: prefer data-cover-fill; else try CSS var --paper; else white
                  const fillAttr = el.getAttribute('data-cover-fill');
                  if(fillAttr){
                    r.setAttribute('fill', fillAttr);
                  }else{
                    r.setAttribute('fill', '#fff');
                    try{ r.setAttribute('style', 'fill: var(--paper, #fff);'); }catch(_){ }
                  }
                  r.setAttribute('stroke', 'none');
                  r.setAttribute('pointer-events','none');
                  r.setAttribute('data-auto','surface-cover');
                  el.appendChild(r);
                  el.__autoSurfaceCover = r;
                }
              }

              const cover = el.__autoSurfaceCover;
              if(cover){
                const dur = Math.max(0.6, Number(el.getAttribute('data-reveal-dur')||0.9));
                // hiện cover đúng lúc hue bắt đầu, rồi "kéo" (height->0) để lộ surface.
                // Dùng attr y/height thay vì scaleY để tránh lỗi transformOrigin trên một số máy.
                const bby = parseFloat(cover.getAttribute('data-bby')||cover.getAttribute('y')||'0') || 0;
                const bbh = parseFloat(cover.getAttribute('data-bbh')||cover.getAttribute('height')||'0') || 0;
                const yEnd = bby + bbh;
                try{ tl.set(cover, { opacity: 1, attr: { y: bby, height: bbh } }, '+=' + currentDelay); }catch(_){ cover.style.opacity = 1; }
                try{ tl.to(cover, { attr: { y: yEnd, height: 0 }, duration: dur, ease: 'none' }, '+=' + currentDelay); }catch(_){ }
                try{ tl.set(cover, { opacity: 0 }, '+=' + (currentDelay + dur)); }catch(_){ cover.style.opacity = 0; }
                currentDelay += dur;
              }
            }
          }catch(_){ }

          // không cộng thời gian đáng kể (ngoại trừ reveal surface ở trên nếu có)
        } else {
          el.style.opacity = 1;
        }
      }catch(_){ }
      return;
    }

    // === Highlight fill effect (data-type="highlight") ===
    if (el.getAttribute('data-type') === 'highlight') {
      const __playAttr = el.getAttribute(' m');
      let __offset = 0;
      let __pauseMode = 'none'; // 'none' | 'svg' | 'both'

      if (__playAttr !== null) {
        const s = String(__playAttr).trim();
        if (s === " ") {
          // data-play=""  → SVG dừng vô hạn, TTS vẫn chạy
          __pauseMode = 'svg';
        } else {
          const v = parseFloat(s);
          if (!isNaN(v)) {
            if (v === 0) {
              // data-play="0" → dừng cả SVG + TTS, chờ click
              __pauseMode = 'both';
            } else if (v > 0) {
              // data-play="n" → SVG dừng n giây, TTS vẫn chạy
              __offset = v;
            }
          }
        }
      }

      const __hideAfter = parseFloat(el.getAttribute('data-hide') || 0);

      currentDelay += __offset;

      let color = getAttrOrStyle(el,'fill') || 'rgba(255,255,255,1)';
      if(!/rgba?\(/i.test(color)){ color = 'rgba(255,255,255,1)'; }
      el.style.fill = 'transparent';
      el.style.stroke = 'none';
      el.style.opacity = 0;
      tl.to(el, { opacity: 1, fill: color, duration: 0.6, ease: 'power1.inOut' }, '+=' + currentDelay);
      currentDelay += 0.6;

      if (__pauseMode !== 'none') {
        tl.call(()=>{ 
          try{
            if(__pauseMode === 'svg'){
              // data-play="" → SVG dừng, chờ [D0]; TTS vẫn chạy
              svgSyncWait = true;
              svgIsPlaying = false;
              if (typeof showPauseCue === 'function') showPauseCue();
            }else if(__pauseMode === 'both'){
              // data-play="0" → giải phóng chờ của TTS (nếu có)
              if(ttsSyncWait){
                ttsSyncWait = false;
                try{
                  if(ttsResumeState){
                    currentPart = ttsResumeState.part;
                    charIndex = ttsResumeState.char || 0;
                  }
                  ttsIsPlaying = true;
                  speakPart();
                }catch(_){}
              }
            }
          }catch(e){} 
        }); 
        if(__pauseMode === 'svg'){ tl.addPause(); }
      }

      if (__hideAfter > 0) tl.to(el, { opacity: 0, duration: 0.3 }, '+=' + __hideAfter);
      return;
    }


    // data-play (như NeboC)


    // data-play (như NeboC)
    const playAttr = el.getAttribute('data-play');
    let offset=0;
    let pauseMode='none'; // 'none' | 'svg' | 'both'
    
    if (playAttr !== null) {
      const s = String(playAttr).trim();
      if (s === " ") {
        // data-play=""  → SVG dừng vô hạn, TTS vẫn chạy
        pauseMode = 'svg';
      } else {
        const v = parseFloat(s);
        if (!isNaN(v)) {
          if (v === 0) {
            // data-play="0" → dừng cả SVG + TTS, chờ click
            pauseMode = 'both';
          } else if (v > 0) {
            // data-play="n" → SVG dừng n giây, TTS vẫn chạy
            offset = v;
          }
        }
      }
    }
    let hideAfter = parseFloat(el.getAttribute('data-hide') || 0);

    currentDelay += offset;

    // === NeboY-style handwriting (single branch, patched) ===
    if(tag==='path'){
      const d = (el.getAttribute('d')||'').trim();
      const isClosedZ = /[zZ]\s*$/.test(d);

      let strokeAttr = el.getAttribute('stroke');
      if(!strokeAttr){
        const styleAttr = el.getAttribute('style') || '';
        const m = styleAttr.match(/stroke\s*:\s*([^;]+)/i);
        if(m) strokeAttr = m[1];
      }
      const strokeIsNone = (strokeAttr && String(strokeAttr).trim().toLowerCase()==='none');

      const inWriteGroup = (el.getAttribute('data-type')==='write') || (el.closest && el.closest('[data-type="write"]'));

      // NEW: path Z-close với stroke xám (#808080) được coi là handwriting write-stroke
      let isGreyStrokeWrite = false;
      if (isClosedZ && !strokeIsNone && strokeAttr){
        const s = String(strokeAttr).trim().toLowerCase();
        if (s === '#808080' || s === 'rgb(128, 128, 128)' || s === 'rgba(128, 128, 128, 1)'){
          isGreyStrokeWrite = true;
        }
      }

      if ((isClosedZ && strokeIsNone) || inWriteGroup || isGreyStrokeWrite){
        const cs = window.getComputedStyle(el);
        let fillAttr = getAttrOrStyle(el,'fill');
        if(!fillAttr){
          const styleAttr = el.getAttribute('style') || '';
          const fm = styleAttr.match(/fill\s*:\s*([^;]+)/i);
          if(fm) fillAttr = fm[1];
        }
        if(!fillAttr) fillAttr = cs.fill || '';
        if(/^url\(/i.test(String(fillAttr)) || !fillAttr || String(fillAttr).toLowerCase()==='none'){
          fillAttr = '#000';
        }

        // Nếu là nét stroke xám (#808080) cho handwriting, giữ màu stroke gốc
        let strokeColor;
        if (isGreyStrokeWrite && strokeAttr && !strokeIsNone){
          strokeColor = strokeAttr;
        } else {
          strokeColor = fillAttr;
        }

        el.style.stroke = strokeColor;
        el.style.fill = 'none';
        // stroke width
const swRaw = el.getAttribute('stroke-width') || cs.strokeWidth || '0.5';
const sw0 = parseFloat(swRaw);
el.style.strokeWidth = String((isFinite(sw0) ||sw0 > 0) ? sw0*0.5 :0.5);

// Nét gọn, mềm tự nhiên
el.style.strokeLinecap = 'butt';
el.style.strokeLinejoin = 'round';
el.style.strokeOpacity = 1;
	el.style.opacity = 0;

        let len = 0;
        try{ if(typeof el.getTotalLength === 'function') len = el.getTotalLength(); }catch(_){ len = 0; }
        if(!isFinite(len) || len<=0){ return; }
        el.style.strokeDasharray = len;
        el.style.strokeDashoffset = len;

        const screenSize = Math.max(1, window.innerWidth*window.innerHeight);
        const screenScale = Math.sqrt(screenSize);
        const duration = Math.max(0.2, 0.2*len/screenScale);

        tl.set(el, {opacity:1}, "+=" + currentDelay);
      tl.to(el, { strokeDashoffset: 0, duration, ease:'power1.inOut' }, "+=" + currentDelay);
        currentDelay = duration;
        if(pauseMode !== 'none'){
          tl.call(()=>{ 
            try{
              if(pauseMode === 'svg'){
                // data-play="" → SVG dừng, chờ [D0]; TTS vẫn chạy
                svgSyncWait = true;
                svgIsPlaying = false;
                if(typeof showPauseCue==='function') showPauseCue();
              }else if(pauseMode === 'both'){
                // data-play="0" → giải phóng chờ của TTS (nếu có)
                if(ttsSyncWait){
                  ttsSyncWait = false;
                  try{
                    if(ttsResumeState){
                      currentPart = ttsResumeState.part;
                      charIndex = ttsResumeState.char || 0;
                    }
                    ttsIsPlaying = true;
                    speakPart();
                  }catch(_){}
                }
              }
            }catch(e){}
          });
          if(pauseMode === 'svg'){ tl.addPause(); }
        }
        if(hideAfter>0) tl.to(el, {opacity:0, duration:0.3}, '+=' + hideAfter);
        return;
      }
    }
    // === End NeboY-style handwriting ===

    // closed-shape fill (NeboN) — fade opacity với 3 mode cho rect
    if (['path','polygon','rect','circle','ellipse'].includes(tag)) {
      let isClosed = false;
      if (tag === 'path') {
        const d = (el.getAttribute('d') || '').trim();
        isClosed = /[zZ]\s*$/.test(d);
      } else {
        isClosed = true;
      }
      if (isClosed) {
        // Mặc định: lấy fill-opacity gốc, nếu không có thì =1
        let targetOpacity = parseFloat(el.getAttribute('fill-opacity') || el.getAttribute('opacity') || '1');
        if (!isFinite(targetOpacity) || targetOpacity <= 0) targetOpacity = 1;

        let maskOnlyFadeOut = false;

        if (tag === 'rect') {
          const rType = (type || el.getAttribute('data-type') || '').toLowerCase();

          if (rType === 'eraser') {
            // brightness <15% || >85% → eraser: ô trắng, 0 → 1, giữ lại
            el.setAttribute('fill', '#ffffff');
            targetOpacity = 1;
            el.setAttribute('fill-opacity', String(targetOpacity));
            el.setAttribute('opacity', '1');

          } else if (rType === 'mask') {
            // 45%<brightness<55% → mask: ô trắng, luôn hiện sẵn; đến lượt thì tắt (1 → 0)
            el.setAttribute('fill', '#ffffff');
            targetOpacity = 1;
            el.setAttribute('fill-opacity', String(targetOpacity));
            el.setAttribute('opacity', '1');
            maskOnlyFadeOut = true;
            // không dùng hideAfter cho mask
            hideAfter = 0;

          } else {
            // Các trường hợp còn lại → rect-grey: xám mờ như cũ
            targetOpacity = 0.5;
            el.setAttribute('fill-opacity', String(targetOpacity));
            el.setAttribute('opacity', '1');
            // nếu muốn ép fill xám chuẩn:
            // el.setAttribute('fill','#808080');
          }

        } else if (tag === 'ellipse') {
          // ellipse giữ logic cũ: mờ 0.5
          targetOpacity = 0.5;
          el.setAttribute('fill-opacity', String(targetOpacity));
          el.setAttribute('opacity', '1');
        }

        if (!maskOnlyFadeOut) {
          // Ẩn lúc đầu (trừ mask)
          gsap.set(el, { opacity: 0 });
        }

        if (maskOnlyFadeOut) {
          // Mask: ô trắng đang hiện sẵn, đến thời điểm thì fade 1 → 0
          tl.to(el, { opacity: 0, duration: 0.3 }, '+=' + currentDelay);
        } else {
          // Bình thường: 0 → targetOpacity
          tl.to(el, { opacity: targetOpacity, duration: 0.3 }, '+=' + currentDelay);
        }
        currentDelay = 0.1;

        if (pauseMode !== 'none') {
          tl.call(() => {
            try{
              if(pauseMode === 'both'){
                // Pause cả TTS + SVG (data-play="0")
                try{ if(window.speechSynthesis && window.speechSynthesis.speaking && !window.speechSynthesis.paused){ window.speechSynthesis.pause(); } }catch(_){}
                try{ bgMusic && !bgMusic.paused && bgMusic.pause(); }catch(_){}
                try{var ds=el && el.getAttribute && el.getAttribute("data-scroll"); if(ds!=null){window.__userScrollLock=false;window.__pendingScroll=ds;window.__tryApplyScrollAnchor&&window.__tryApplyScrollAnchor(ds,true);}}catch(_){ }
                waitingForClick = "both";
                svgIsPlaying = false;
                ttsIsPlaying = false; scheduleAutoResume();
}else{
                // Chỉ dừng SVG, TTS vẫn chạy
                waitingForClick = "svg";
                svgIsPlaying = false;
              }
              if (typeof showPauseCue === 'function') showPauseCue();
            }catch(e){}
          });
          tl.addPause();
        }

        if (!maskOnlyFadeOut && hideAfter > 0) {
          tl.to(el, { opacity: 0, duration: 0.3 }, '+=' + hideAfter);
        }
        return;
      }
    }


if(['path','line','polyline','polygon'].includes(tag)){
      const stroke = el.getAttribute('stroke') || window.getComputedStyle(el).stroke;
      const s = (stroke||'').replace(/\s+/g,'').toLowerCase();
      const isBlack = ['black','#000','rgb(0,0,0)','rgba(0,0,0,1)'].includes(s);
      if(isBlack){ el.setAttribute('stroke-dasharray','10 5'); }
    }

    if(type==='dash' && (tag==='path'||tag==='line'||tag==='polyline')){
      const dashLength=10, gapLength=5;
      let length = el.getTotalLength?.() || 0;
      if(length===0 && tag==='line'){
        const x1=+el.getAttribute('x1'), y1=+el.getAttribute('y1');
        const x2=+el.getAttribute('x2'), y2=+el.getAttribute('y2');
        length = Math.hypot(x2-x1, y2-y1);
      }
      let cur=0;
      while(cur<length){
        const spt = el.getPointAtLength(cur);
        cur += dashLength; if(cur>length) cur=length;
        const ept = el.getPointAtLength(cur);
        const dash = document.createElementNS('http://www.w3.org/2000/svg','path');
        dash.setAttribute('d', `M ${spt.x} ${spt.y} L ${ept.x} ${ept.y}`);
        const cs = window.getComputedStyle(el);
        dash.setAttribute('stroke', el.getAttribute('stroke') || cs.stroke || 'black');
        dash.setAttribute('stroke-width', el.getAttribute('stroke-width') || cs.strokeWidth || '0.5');
        dash.setAttribute('fill','none');
        dash.style.opacity=0;
        el.parentNode.insertBefore(dash, el);
        tl.to(dash, {opacity:1, duration:0.1}, '+=' + currentDelay);
        currentDelay = 0.03;
        cur += gapLength;
      }
      el.style.opacity=0;
      if(pauseMode !== 'none'){ 
        tl.call(()=>{ 
          try{
            if(pauseMode === 'both'){
              // Pause cả TTS + SVG (data-play="0")
              try{ if(window.speechSynthesis && window.speechSynthesis.speaking && !window.speechSynthesis.paused){ window.speechSynthesis.pause(); } }catch(_){}
              try{ bgMusic && !bgMusic.paused && bgMusic.pause(); }catch(_){}
              try{var ds=el && el.getAttribute && el.getAttribute("data-scroll"); if(ds!=null){window.__userScrollLock=false;window.__pendingScroll=ds;window.__tryApplyScrollAnchor&&window.__tryApplyScrollAnchor(ds,true);}}catch(_){ }
                waitingForClick = "both";
              svgIsPlaying = false;
              ttsIsPlaying = false; scheduleAutoResume();
}else{
              // Chỉ dừng SVG, TTS vẫn chạy
              waitingForClick = "svg";
              svgIsPlaying = false;
            }
            if(typeof showPauseCue==='function') showPauseCue();
          }catch(e){}
        }); 
        tl.addPause(); 
      }

      if(hideAfter>0) tl.to(el, {opacity:0, duration:0.2}, '+=' + hideAfter);
      return;
    }

    if((tag==='path'||tag==='line'||tag==='polyline'||tag==='polygon') && typeof el.getTotalLength==='function'){
      const cs = window.getComputedStyle(el);
      let strokeColor = el.getAttribute('stroke') || cs.stroke || '#000';
      el.style.stroke = strokeColor;
      el.style.fill = 'none';
      el.style.strokeWidth = el.getAttribute('stroke-width') || cs.strokeWidth || '0.5';
      el.style.opacity=0;
      const len = el.getTotalLength();
      el.style.strokeDasharray = len;
      el.style.strokeDashoffset = len;
      const screenSize = Math.max(1, window.innerWidth*window.innerHeight);
      const screenScale = Math.sqrt(screenSize);
      const duration = Math.max(0.2, 0.2*len/screenScale);
      tl.to(el, { opacity: 1, duration: 0 }, '+=' + currentDelay);
      tl.to(el, { strokeDashoffset: 0, duration, ease:'power1.inOut' }, '<');
      currentDelay = duration;
      if(pauseMode !== 'none'){ 
        tl.call(()=>{ 
          try{
            if(pauseMode === 'both'){
              // Pause cả TTS + SVG (data-play="0")
              try{ if(window.speechSynthesis && window.speechSynthesis.speaking && !window.speechSynthesis.paused){ window.speechSynthesis.pause(); } }catch(_){}
              try{ bgMusic && !bgMusic.paused && bgMusic.pause(); }catch(_){}
              try{var ds=el && el.getAttribute && el.getAttribute("data-scroll"); if(ds!=null){window.__userScrollLock=false;window.__pendingScroll=ds;window.__tryApplyScrollAnchor&&window.__tryApplyScrollAnchor(ds,true);}}catch(_){ }
                waitingForClick = "both";
              svgIsPlaying = false;
              ttsIsPlaying = false; scheduleAutoResume();
}else{
              // Chỉ dừng SVG, TTS vẫn chạy
              waitingForClick = "svg";
              svgIsPlaying = false;
            }
            if(typeof showPauseCue==='function') showPauseCue();
          }catch(e){}
        }); 
        tl.addPause(); 
      }

if(hideAfter>0) tl.to(el, {opacity:0, duration:0.2}, '+=' + hideAfter);
      return;
    }

    if (tag === 'text' || tag === 'tspan') {
  let tspans = [];
  if (tag === 'text') {
    const found = el.querySelectorAll('tspan');
    if (found.length) tspans = [...found];
    else {
      const orig = el.textContent || '';
      el.textContent = '';
      const sp = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      sp.setAttribute('x', el.getAttribute('x') || 0);
      sp.setAttribute('y', el.getAttribute('y') || 0);
      sp.textContent = orig;
      el.appendChild(sp);
      tspans = [sp];
    }
  } else {
    tspans = [el];
  }

  // ===== PATCH: tspan data-type="dashstatic" => show instantly, NO typing =====
  const isDash = (node) =>
    ((node.getAttribute('data-type') || '').toLowerCase().includes('dash'));

  // 1) xử lý dash trước: hiện 1 lần theo timeline, không tách ký tự
  tspans.forEach(tspan => {
    if (!isDash(tspan)) return;

    // không can thiệp fill/stroke => giữ màu theo data-hue/currentColor
    tspan.style.opacity = 0;

    // nếu tspan trước đó đã bị split (do chạy nhầm), thì gộp lại text
    // (an toàn: nếu không split thì textContent vẫn đúng)
    // NOTE: không đụng children nếu bạn không muốn; dòng dưới chỉ lấy text hiện có
    const keepText = tspan.textContent || '';
    tspan.textContent = keepText;

    tl.to(tspan, { opacity: 1, duration: 0.12, ease: 'none' }, '+=' + currentDelay);
    currentDelay = 0.2;
  });

  // 2) typing chỉ áp dụng cho tspans KHÔNG phải dash
  tspans
    .filter(tspan => !isDash(tspan))
    .forEach(tspan => {
      const orig = tspan.textContent || '';
      tspan.textContent = '';

      for (let i = 0; i < orig.length; i++) {
        const ch = orig[i];
        const sp = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
        sp.textContent = ch;
        sp.style.opacity = 0;
        tspan.appendChild(sp);
        tl.to(sp, { opacity: 1, duration: 0.2 }, '+=' + currentDelay);
        currentDelay = 0.2;
      }
    });


      if(pauseMode !== 'none'){ 
        tl.call(()=>{ 
          try{
            if(pauseMode === 'both'){
              // Pause cả TTS + SVG (data-play="0")
              try{ if(window.speechSynthesis && window.speechSynthesis.speaking && !window.speechSynthesis.paused){ window.speechSynthesis.pause(); } }catch(_){}
              try{ bgMusic && !bgMusic.paused && bgMusic.pause(); }catch(_){}
              try{var ds=el && el.getAttribute && el.getAttribute("data-scroll"); if(ds!=null){window.__userScrollLock=false;window.__pendingScroll=ds;window.__tryApplyScrollAnchor&&window.__tryApplyScrollAnchor(ds,true);}}catch(_){ }
                waitingForClick = "both";
              svgIsPlaying = false;
              ttsIsPlaying = false; scheduleAutoResume();
}else{
              // Chỉ dừng SVG, TTS vẫn chạy
              waitingForClick = "svg";
              svgIsPlaying = false;
            }
            if(typeof showPauseCue==='function') showPauseCue();
          }catch(e){}
        }); 
        tl.addPause(); 
      }

      if(hideAfter>0) tl.to(el, {opacity:0, duration:0.2}, '+=' + hideAfter);
      return;
    }

    el.style.opacity=0;
    tl.to(el, {opacity:1, duration:0.5}, '+=' + currentDelay);
    currentDelay = 0.5;
      if(pauseMode !== 'none'){ 
        tl.call(()=>{ 
          try{
            if(pauseMode === 'both'){
              // Pause cả TTS + SVG (data-play="0")
              try{ if(window.speechSynthesis && window.speechSynthesis.speaking && !window.speechSynthesis.paused){ window.speechSynthesis.pause(); } }catch(_){}
              try{ bgMusic && !bgMusic.paused && bgMusic.pause(); }catch(_){}
              try{var ds=el && el.getAttribute && el.getAttribute("data-scroll"); if(ds!=null){window.__userScrollLock=false;window.__pendingScroll=ds;window.__tryApplyScrollAnchor&&window.__tryApplyScrollAnchor(ds,true);}}catch(_){ }
                waitingForClick = "both";
              svgIsPlaying = false;
              ttsIsPlaying = false; scheduleAutoResume();
}else{
              // Chỉ dừng SVG, TTS vẫn chạy
              waitingForClick = "svg";
              svgIsPlaying = false;
            }
            if(typeof showPauseCue==='function') showPauseCue();
          }catch(e){}
        }); 
        tl.addPause(); 
      }

if(hideAfter>0) tl.to(el, {opacity:0, duration:0.2}, '+=' + hideAfter);
  });

  tl.eventCallback('onStart', ()=>{ if(!tl.paused()) showPlayCue(); });
  tl.eventCallback('onComplete', ()=>{
    svgIsPlaying=false;
    stopBgMusicIfAllDone(); 
    if(!ttsIsPlaying){ svgContainer.style.outline="none"; triggerFinalEffect(); }
  });
}

/* ==================== INIT (kết hợp) ==================== */
const params = new URLSearchParams(location.search);

// PATCH: default NO=true (no URL/device)
window.__noSplit = true;


const svgPath = params.get('svg') || params.get('file');
if(!svgPath){
  if (!window.__DEFER_SVG_LOAD) {
    svgContainer.textContent = 'Thiếu tham số  ?file=... để tải SVG';
  }
}else{
  fetch(svgPath).then(r=>r.text()).then(txt=>{
    svgContainer.innerHTML = txt;
    const svg = svgContainer.querySelector('svg');
// >>> chạy lại các <script> trong SVG
svg.querySelectorAll('script').forEach(oldScript => {
  const t = (oldScript.type || '').trim().toLowerCase();
  // Giữ lại script dạng data (không execute), ví dụ bank specs:
  if(t === 'application/svgjson'){
    return; // KHÔNG remove
  }
  const newScript = document.createElement('script');
  if (oldScript.type) newScript.type = oldScript.type;
  newScript.textContent = oldScript.textContent;
  document.body.appendChild(newScript); // ép browser thực thi
  oldScript.remove();
});

    // Split (NeboN): chuyển phần tử vào part1/part2 nếu có path[data-type="split"]
    (function applySplit(){
      if(!svg) return;
      const marker = svg.querySelector('path[data-type="split"]');
      if(!marker) return; // không có split thì thôi

      // Tạo 2 phần
      const part1 = document.createElementNS('http://www.w3.org/2000/svg','g'); part1.id='part1';
      const part2 = document.createElementNS('http://www.w3.org/2000/svg','g'); part2.id='part2';

      // Duyệt theo thứ tự DOM gốc: các node trước marker -> part1, sau marker -> part2
      const DRAW_TAGS = new Set(['path','line','polyline','polygon','rect','circle','ellipse','text','image','g']);
      const children = Array.from(svg.childNodes).filter(n => n.nodeType===1 && DRAW_TAGS.has((n.tagName||'').toLowerCase()));

      let before = true;
      for(const el of children){
        if(el === marker){ before = false; continue; } // bỏ chính marker
        (before ? part1 : part2).appendChild(el);
      }

      // PATCH: chỉnh lại rect/ellipse có gắn data-part-mask="1|2"
      // để chúng đi đúng nửa 1/2, mà không cần tham gia data-band
      try {
        const groups = [part1, part2];
        const moves = [];
        groups.forEach((g, idx)=>{
          if (!g) return;
          const kids = Array.from(g.childNodes);
          kids.forEach(el=>{
            if (el.nodeType !== 1) return;
            const tag = (el.tagName || '').toLowerCase();
            if (tag !== 'rect' && tag !== 'ellipse') return;
            if (!el.getAttribute) return;
            const pm = el.getAttribute('data-part-mask');
            if (pm !== '1' && pm !== '2') return;
            const wantIdx = (pm === '1') ? 0 : 1;
            const target = groups[wantIdx];
            if (target && target !== g){
              moves.push({ el, target });
            }
          });
        });
        moves.forEach(m => {
          try { m.target.appendChild(m.el); } catch(_){}
        });
      } catch(_){}

      // Gắn vào svg theo đúng thứ tự (part1 trước, part2 sau)
      svg.appendChild(part1);
      svg.appendChild(part2);

      // Ẩn marker cho sạch, nhưng vẫn giữ lại để debug khi cần (có thể comment 2 dòng dưới)
      marker.setAttribute('visibility','hidden');
      marker.setAttribute('pointer-events','none');
    })();

    // === Classify fill-only paths into handwriting vs stroke/fill (refined) ===
    /* DISABLED: classifyFillVsWrite alpha-based highlight/eraser logic */
(function classifyFillVsWrite(svg){
      if(!svg) return;
      const getAttrOrStyle = (el, name) => {
        let v = el.getAttribute(name);
        if(v && String(v).trim()) return String(v).trim();
        const s = el.getAttribute('style') || '';
        const m = s.match(new RegExp(name+'\\s*:\\s*([^;]+)','i'));
        return m ? m[1].trim() : '';
      };
      svg.querySelectorAll('path').forEach(el=>{
        // Skip fully static elements (or those inside a static group)
        try{
          let p = el;
          while(p){
            if (p.getAttribute && (p.getAttribute('data-type')||'').toLowerCase()==='static'){
              return; // do not touch static handwriting (keep fill, no animation)
            }
            p = p.parentNode;
          }
        }catch(_){}

        // --- PATCH: Treat any element with explicit fill-opacity=1 as an ERASER (keep as fill) ---
        (function(){
          try{
            const fo = (getAttrOrStyle(el,'fill-opacity') || '').trim();
            const opa = (el.getAttribute('opacity') || '').trim();
            const isFull = /^(1(?:\.0+)?)$/.test(fo) || /^(1(?:\.0+)?)$/.test(opa);
            if (isFull){
              let f = getAttrOrStyle(el,'fill') || '#ffffff';
              if (!/^#?fff(?:fff)?$/i.test(f) && !/rgba?\(/i.test(f)) f = '#ffffff';
              el.setAttribute('data-type','highlight');
              el.setAttribute('fill', f);
              el.setAttribute('stroke','none');
              el.setAttribute('opacity','1');
              return;
            }
          }catch(e){}
        })();

        const d = (el.getAttribute('d') || '').trim();
        const isClosedZ = /[zZ]\s*$/.test(d);
        const fill = getAttrOrStyle(el,'fill');
        let stroke = getAttrOrStyle(el,'stroke');
        const strokeIsNone = (!stroke || /^none$/i.test(stroke));
        const hasFill = (!!fill && !/^none$/i.test(fill) && !/^url\(/i.test(fill));

        // Handwriting rule: closeZ + stroke none + has fill
        if(isClosedZ && strokeIsNone && hasFill){
          el.setAttribute('stroke', fill);
          el.setAttribute('fill', 'none');
          el.setAttribute('data-type','write');
          return;
        }

        // Open-path with fill only: treat as stroked outline (EXCEPT semi-transparent fill -> highlight)
        if(!isClosedZ && strokeIsNone && hasFill){
          let f = String(fill||'').trim();
          let m = f.match(/rgba?\(([^)]+)\)/i);
          if(m){
            let parts = m[1].split(',').map(s=>s.trim()).filter(Boolean);
            let r = parseFloat(parts[0]||'0'), g = parseFloat(parts[1]||'0'), b = parseFloat(parts[2]||'0');
            let alpha = (parts.length>=4) ? parseFloat(parts[3]) : NaN;
            if(!isNaN(alpha) && alpha <= 0.5){
              const nearBlack = (isFinite(r)&&isFinite(g)&&isFinite(b) && (r<16 && g<16 && b<16));
if(!nearBlack){ r=255; g=255; b=255; f = 'rgba(' + [255,255,255,'1'].join(',') + ')'; }
else { f = 'rgba(' + [Math.round(r),Math.round(g),Math.round(b),'0.4'].join(',') + ')'; }
              el.setAttribute('fill', f);
              el.setAttribute('stroke', 'none');
              el.setAttribute('data-type', 'highlight');
              // Also raise to top if near white
              if(r>200 && g>200 && b>200){ try{ svg.appendChild(el); }catch(_){ } }
              return;
            }
          }
          // default: convert to stroked outline
          el.setAttribute('stroke', fill);
          el.setAttribute('fill', 'none');
          return;
        }

        // If stroke exists or no fill, leave as-is.
      });
    })(svg);


/* END DISABLED classifyFillVsWrite */
// === Normalize highlights (eraser): force rgba(255,255,255,0.4), open path, bring to top ===

// === Normalize highlights (eraser): paint with PAGE background color, draw on top ===
/* DISABLED: normalizeHighlights alpha-based eraser/highlight */
(function normalizeHighlights(svg){
  try{
    const getAttrOrStyle = (el, name) => {
      let v = el.getAttribute(name);
      if(v && String(v).trim()) return String(v).trim();
      const s = el.getAttribute('style') || '';
      const m = s.match(new RegExp(name+'\s*:\s*([^;]+)','i'));
      return m ? m[1].trim() : '';
    };

    // Detect page/background fill color from a large rect covering the viewBox
    let pageFill = '#ffffff';
    try{
      const vb = (svg.getAttribute('viewBox')||'').trim().split(/[,\s]+/).map(Number);
      const [vx,vy,vw,vh] = (vb.length===4 ? vb : [0,0,0,0]);
      let bestRect = null, bestArea = -1;
      svg.querySelectorAll('rect').forEach(r=>{
        const x = parseFloat(r.getAttribute('x')||'0'),
              y = parseFloat(r.getAttribute('y')||'0'),
              w = parseFloat(r.getAttribute('width')||'0'),
              h = parseFloat(r.getAttribute('height')||'0');
        const area = Math.abs(w*h);
        // heuristics: take the largest rect that roughly spans the page
        if (isFinite(area) && area > bestArea && w>=0.8*vw && h>=0.8*vh){
          bestArea = area; bestRect = r;
        }
      });
      if (bestRect){
        const f = getAttrOrStyle(bestRect,'fill');
        if (f && !/^none$/i.test(f)) pageFill = f;
      } else {
        // fallback: try svg's background-color
        const bc = getAttrOrStyle(svg,'background-color');
        if (bc && !/^transparent$/i.test(bc)) pageFill = bc;
      }
    }catch(_){}

    svg.querySelectorAll('path').forEach(el=>{
      const fill = getAttrOrStyle(el,'fill');
      const opacity = getAttrOrStyle(el,'opacity');
      const type = (el.getAttribute('data-type')||'').toLowerCase();

      // parse rgba(...) alpha or separate opacity
      let alpha = 1;
      const m = (fill||'').match(/rgba?\(([^)]+)\)/i);
      if (m){
        const parts = m[1].split(/\s*,\s*/);
        if (parts.length===4){
          const a = parseFloat(parts[3]);
          if (!isNaN(a)) alpha = a;
        }
      }
      if (opacity){
        const a2 = parseFloat(opacity);
        if (!isNaN(a2)) alpha = Math.min(alpha, a2);
      }

      if (type==='highlight' || alpha <= 0.5 || (String(getAttrOrStyle(el,'fill-opacity')||'').trim().match(/^(1(?:\.0+)?)$/))){
        try{
          // ensure open path: drop trailing Z/z
          const d0 = (el.getAttribute('d') || '');
          if (/[zZ]\s*$/.test(d0)){
            el.setAttribute('d', d0.replace(/[zZ]\s*$/, '').trim());
          }
        }catch(_){}

        // Paint exactly with page background (full opacity) to "erase"
        el.setAttribute('data-type','highlight');
        el.setAttribute('fill', pageFill);
        el.setAttribute('opacity','1');
        el.setAttribute('stroke','none');
        el.removeAttribute('filter');
        el.removeAttribute('mask');
        el.style.mixBlendMode = 'normal';
        el.style.pointerEvents = 'none';

        // Bring on top
        try { el.parentNode && el.parentNode.appendChild(el); } catch(_){}
      }
    });
  }catch(_){}
})(svg)
/* END DISABLED normalizeHighlights */
;

    svg.querySelectorAll('g[data-type]').forEach(group=>{
      const type = group.getAttribute('data-type');
      group.querySelectorAll('*').forEach(child=>{
        if(!child.hasAttribute('data-type')) child.setAttribute('data-type', type);
      });
    });

    // mark dashed
    markDashed(svg);

    // Lấy TTS
    texttts = extractTTSFromSVG(svg);
// === NEW: copy data-hue từ group xuống con ===
    svg.querySelectorAll('g[data-hue]').forEach(g=>{
      const hue = g.getAttribute('data-hue');
      g.querySelectorAll('path, rect, circle, ellipse, polygon, line, polyline, text, tspan, image')
        .forEach(child=>{
          if(!child.hasAttribute('data-hue')){
            child.setAttribute('data-hue', hue);
          }
        });
    });
// === Reorder DOM per-parent by data-hue (ascending) => higher hue renders on top ===
(function reorderDomByHue(svg){
  try{
    const DRAW_TAGS = new Set(['path','line','polyline','polygon','rect','circle','ellipse','text','image']);
    const parents = [svg, ...svg.querySelectorAll('g')];

    function hueOf(el){
      const tag = (el.tagName || '').toLowerCase();
      // Với <text>: luôn ưu tiên data-hue nằm trong <tspan>, vì data-hue trên <text>
      // thường bị gắn trật (mặc định 00 do không có màu).
      if (tag === 'text') {
        const span = el.querySelector('tspan[data-hue]');
        if (span) {
          const vv = parseInt((span.getAttribute('data-hue')||'').trim(), 10);
          if (Number.isFinite(vv)) return vv;
        }
        // Không tin data-hue trên <text>, nếu không có gì thì trả 0
        return 0;
      }
      const v = parseInt((el.getAttribute('data-hue')||'').trim(), 10);
      return Number.isFinite(v) ? v : 0;
    }
    function typeOf(el){
      return (el.getAttribute('data-type')||'').toLowerCase();
    }

    parents.forEach(parent=>{
      const kids = Array.from(parent.childNodes)
        .filter(n => n.nodeType === 1 && DRAW_TAGS.has((n.tagName||'').toLowerCase()));
      if (kids.length <= 1) return;

      const origIndex = new Map();
      kids.forEach((el, i)=> origIndex.set(el, i));

      kids.sort((a, b) => {
        const ta = typeOf(a), tb = typeOf(b);

        // keep split markers at their original relative positions
        if (ta === 'split' || tb === 'split') {
          return (origIndex.get(a) - origIndex.get(b));
        }

        // push highlights to render on top
        if (ta === 'highlight' && tb !== 'highlight') return  1;
        if (tb === 'highlight' && ta !== 'highlight') return -1;

        const ha = hueOf(a), hb = hueOf(b);
        if (ha !== hb) return ha - hb;
        return (origIndex.get(a) - origIndex.get(b));
      });

      kids.forEach(el => { try{ parent.appendChild(el); }catch(_){ } });
    });
  }catch(_){}
})(svg);

    // === Normalize handwriting + text color to near-black (keep data-hue for logic) ===
    (function normalizeWritesAndText(svg){
      if (!svg) return;
      const NEAR_BLACK = '#000000'; // gần đen, hợp cả chế độ nền trắng lẫn đảo màu

      function isEraserOrHighlight(el){
        const t = (el.getAttribute('data-type') || '').toLowerCase();
        if (t === 'highlight') return true;

        const op  = el.getAttribute('opacity') || el.style.opacity || '';
        const fop = el.getAttribute('fill-opacity') || el.style.fillOpacity || '';
        const parseA = v => {
          const x = parseFloat(v);
          return isNaN(x) ? null : x;
        };
        const a1 = parseA(op), a2 = parseA(fop);
        const alpha = (a1 != null) ? a1 : (a2 != null ? a2 : null);
        if (alpha != null && alpha <= 0.5) return true; // các nét mờ (highlight/eraser)
        return false;
      }

      const nodes = svg.querySelectorAll('path, line, polyline, polygon, text, tspan');
      nodes.forEach(el => {
        const tag  = el.tagName.toLowerCase();
        const type = (el.getAttribute('data-type') || '').toLowerCase();
        if (isEraserOrHighlight(el)) return;

        const inWriteGroup = (type === 'write') || (el.closest && el.closest('[data-type="write"]'));
        const isText = (tag === 'text' || tag === 'tspan');

        // Chỉ chuẩn hoá: nét viết (write) + chữ (text/tspan)
        if (!inWriteGroup && !isText) return;

        if (!isText) {
          // Nét viết: stroke near-black, không fill
          el.setAttribute('stroke', NEAR_BLACK);
          el.style.stroke = NEAR_BLACK;
          el.setAttribute('fill', 'none');
          el.style.fill = 'none';
          return;
        }

        // Text/tspan: fill near-black, bỏ stroke nếu có
        let fill = el.getAttribute('fill') || el.style.fill || '';
        fill = (fill || '').trim().toLowerCase();
        if (!fill || fill === 'none') {
          // Không có fill, có thể có stroke → ép stroke near-black
          el.setAttribute('stroke', NEAR_BLACK);
          el.style.stroke = NEAR_BLACK;
        } else {
          el.setAttribute('fill', NEAR_BLACK);
          el.style.fill = NEAR_BLACK;
          el.setAttribute('stroke','none');
          el.style.stroke = 'none';
        }
      });
    })(svg);
    // --- Compile bank specs embedded in SVG + apply placeholders (data-svg) ---
    try{ window.compileSVGBank && window.compileSVGBank(); }catch(e){ console.warn(e); }
    try{ window.applySVGBank && window.applySVGBank(svgContainer); }catch(e){ console.warn(e); }



    // Build timeline
    buildTimeline(svg);
    try{ window.__FoEnableHighlightOverlay(svg); }catch(_){}

    // Click + Space dùng togglePlay (NeboC)
    svgContainer.addEventListener('click', togglePlay);
    

    // fitSvg + orientation (giống NeboN)
    fitSvg();
    applyOrientation();
    window.addEventListener('resize', ()=>{ applyOrientation(); });
  }).catch(e=>{
    svgContainer.textContent = 'Không thể tải SVG: ' + e;
  });
}

/* === auto fit viewBox + orientation (NeboN giữ nguyên) === */
function fitSvg(pad = 0){
  const svg = document.querySelector('#svgContainer svg');
  if(!svg) return;

  let vb = svg.getAttribute('viewBox');
  if(vb){
    let parts = vb.split(/[, ]+/).map(Number);
    if(parts.length === 4){
      let [vx, vy, vw, vh] = parts;
      if(vx !== 0 || vy !== 0){
        let wrapper = svg.querySelector('g.__viewshift');
        if(!wrapper){
          wrapper = document.createElementNS('http://www.w3.org/2000/svg','g');
          wrapper.classList.add('__viewshift');
          [...svg.children].forEach(ch=>{
            if(ch.tagName !== 'defs' && !ch.classList.contains('__viewshift')){
              wrapper.appendChild(ch);
            }
          });
          svg.appendChild(wrapper);
        }
        wrapper.setAttribute('transform', `translate(${-vx} ${-vy})`);
        svg.setAttribute('viewBox', `0 0 ${vw} ${vh}`);
      }
    }
  }

  const bbox = svg.getBBox();
  const x = bbox.x - pad;
  const y = bbox.y - pad;
  const w = bbox.width  + pad*2;
  const h = bbox.height + pad*2;
  
  svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
  svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
}

function applyOrientation(){
  // This stub is overridden by the enhanced orientation patch below.
  // Keep minimal behavior in case it runs first.
  const portrait = window.innerHeight > window.innerWidth;
  const svg = document.querySelector('#svgContainer svg');
  const container = document.getElementById('svgContainer');
  if(!svg || !container) return;
  const noSplit = !!(window.__noSplit);
  if (noSplit) {
    // same as single-part logic
    const vb = (svg.getAttribute('viewBox')||"").split(/[, ]+/).map(Number);
    const w = vb[2]||1, h = vb[3]||1;
    const svgPortrait = h > w;
    if ((portrait && svgPortrait) || (!portrait && !svgPortrait)) {
      svg.style.width = '100%'; svg.style.height = '100%';
      container.style.overflowX='hidden'; container.style.overflowY='hidden';
    } else {
      if (portrait){ svg.style.width='auto'; svg.style.height='100vh'; container.style.overflowX='auto'; container.style.overflowY='hidden'; }
      else { svg.style.width='100vw'; svg.style.height='auto'; container.style.overflowX='hidden'; container.style.overflowY='auto'; }
    }
    return;
  }
  // default fallback
  if(portrait){
    svg.style.width = 'auto'; svg.style.height = '100vh';
    container.style.overflowX = 'auto'; container.style.overflowY = 'hidden';
  }else{
    svg.style.width = '100vw'; svg.style.height = 'auto';
    container.style.overflowX = 'hidden'; container.style.overflowY = 'auto';
  }
}
</script>

<!-- Orientation + Fit-to-BBox enhanced patch by ChatGPT -->
<script>
(function(){
  let originalViewBox = null;

  function unionBBox(bb1, bb2){
    if(!bb1) return bb2;
    if(!bb2) return bb1;
    const x = Math.min(bb1.x, bb2.x);
    const y = Math.min(bb1.y, bb2.y);
    const maxX = Math.max(bb1.x + bb1.width, bb2.x + bb2.width);
    const maxY = Math.max(bb1.y + bb1.height, bb2.y + bb2.height);
    return {x, y, width: maxX - x, height: maxY - y};
  }

  function computeTightViewBox(svg){
    try{
      const elems = svg.querySelectorAll('path,rect,circle,ellipse,line,polyline,polygon,g,text');
      let box = null;
      elems.forEach(el=>{
        if (typeof el.getBBox === 'function') {
          try{
            const b = el.getBBox();
            if (isFinite(b.x) && isFinite(b.y) && isFinite(b.width) && isFinite(b.height) &&
                b.width >= 0 && b.height >= 0) {
              box = unionBBox(box, b);
            }
          }catch(e){/* ignore */}
        }
      });
      if(!box || box.width === 0 || box.height === 0){
        // Fallback to root bbox
        const b = svg.getBBox && svg.getBBox();
        if (b && isFinite(b.width) && isFinite(b.height) && (b.width||b.height)) box = b;
      }
      if(box){
        // Add a small margin
        const m = Math.max(2, Math.min(box.width, box.height)*0.02);
        return [box.x - m, box.y - m, box.width + 2*m, box.height + 2*m];
      }
    }catch(e){/* ignore */}
    return null;
  }

  function ensureSizing(svg){
    // If width/height attributes are absolute px, they can force tiny display — remove them.
    svg.removeAttribute('width');
    svg.removeAttribute('height');
    svg.setAttribute('preserveAspectRatio','xMidYMid meet');
    // CSS sizing
    svg.style.display = 'block';
    svg.style.width   = '100%';
    svg.style.height  = '100%';
   
  }

  // --- helper: bật/tắt z-index cho nút 

function updateLayout(svg){
  if (!svg) return;

  
  // (STABLE) Do not re-layout while playing (mobile viewport is unstable)
  try{ if(window.__layoutLocked) return; }catch(_){ }
// Seed original viewBox
  if (!originalViewBox || originalViewBox.length !== 4){
    let vbStr = (svg.getAttribute('viewBox') || '').trim();
    if (!vbStr){
      const tight0 = computeTightViewBox(svg);
      if (tight0){
        vbStr = tight0.join(' ');
        svg.setAttribute('viewBox', vbStr);
      }
    }
    if (vbStr) originalViewBox = vbStr.split(/[, ]+/).map(Number);
  }
  if (!originalViewBox || originalViewBox.length !== 4) return;

  let [x, y, w, h] = originalViewBox;
  const isScreenPortrait = window.innerHeight > window.innerWidth;
  let   isSvgPortrait    = h > w;

  const noSplit = !!window.__noSplit;
  const part2   = (!noSplit) && svg.querySelector('#part2');
  const halfW   = w/2, halfH = h/2;

  // Khi &no: ép viewBox = tight bbox để phóng sát nét vẽ
  if (noSplit){
    try{
      const tight = computeTightViewBox(svg);
      if (tight && tight.length === 4){
        [x,y,w,h] = tight;
        svg.setAttribute('viewBox', tight.join(' '));
        originalViewBox = tight.slice();
        isSvgPortrait = h > w;
      }
    }catch(_){}
  }

  // 1) ViewBox & dời part2 (nếu có)
  if (part2){
    if (!isScreenPortrait && isSvgPortrait){
      // màn hình ngang, SVG dọc -> đặt 2 nửa cạnh nhau
      svg.setAttribute('viewBox', `${x} ${y} ${2*w} ${halfH}`);
      part2.setAttribute('transform', `translate(${w}, -${halfH})`);
    } else if (isScreenPortrait && !isSvgPortrait){
      // màn hình dọc, SVG ngang -> chồng dọc
      svg.setAttribute('viewBox', `${x} ${y} ${halfW} ${2*h}`);
      part2.setAttribute('transform', `translate(-${halfW}, ${h})`);
    } else {
      // mặc định
      svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
      part2.removeAttribute('transform');
    }
  } else {
    // single-part (gốc 1 phần hoặc do &no)
    svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
  }

  // 2) Fit + scroll
  const container = document.getElementById('svgContainer') || document.querySelector('#svgContainer');
  if (!container) return;

// __RESET_SCROLL_SAME_DIR_V1__
// Always clear leftover scrollable state when layout recomputes.
try{
  container.classList.remove('opp-x');
  container.classList.remove('opp-y');
  container.classList.remove('no-opp-2x');
  // Default: lock overflow; scroll controller may enable later on manual pause.
  container.style.overflow  = 'hidden';
  container.style.overflowX = 'hidden';
  container.style.overflowY = 'hidden';
  // Reset SVG size baseline; opposite+noSplit will override.
  svg.style.width  = '100%';
  svg.style.height = '100%';
}catch(_ ){}
  if (part2){
    // Hai phần: gọn, không scroll; fit theo tỉ lệ
    

container.style.justifyContent="center";
container.style.alignItems="center";

    container.style.overflow  = 'hidden';
    container.style.overflowX = 'hidden';
    container.style.overflowY = 'hidden';
    const screenRatio = window.innerWidth / window.innerHeight;
    const svgRatio    = w / h;
 
    return;
  }

  // --- SINGLE-PART ---
  if (noSplit){
    // Bỏ flex để overflow hoạt động
  

container.style.justifyContent="center";
container.style.alignItems="center";

    container.style.justifyContent = 'center';
    container.style.alignItems = 'center';
    
    // SVG bám container
    svg.removeAttribute('width');
    svg.removeAttribute('height');
    svg.style.maxWidth  = 'none';
    svg.style.maxHeight = 'none';
    svg.style.display   = 'block';
    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

    if ((isScreenPortrait && isSvgPortrait) || (!isScreenPortrait && !isSvgPortrait)){
      // CÙNG CHIỀU → full, KHÔNG scroll
      svg.style.width  = '100%';
      svg.style.height = '100%';
      container.style.overflow  = 'hidden';
      container.style.overflowX = 'hidden';
      container.style.overflowY = 'hidden';
    } else if (isScreenPortrait && !isSvgPortrait){
      // Screen dọc, SVG ngang → FULL DỌC, scroll NGANG
      svg.style.width  = '100%';
      svg.style.height = '100%';
    
      container.classList.remove('no-opp-2x');
      container.style.overflowX = 'auto';
      container.style.overflowY = 'hidden';
    } else {
      // Screen ngang, SVG dọc → FULL NGANG, scroll DỌC
      svg.style.width  = '100%';
      svg.style.height = '100%';
      
      container.classList.remove('no-opp-2x');
      container.style.overflowX = 'hidden';
      container.style.overflowY = 'auto';
    }
  } else 
{
    // Single-part nhưng không &no: CHỐT ổn định → luôn KHÔNG scroll (chỉ &no + trái chiều mới tạo scroll)
    try{ container.classList.remove('opp-x'); container.classList.remove('opp-y'); container.classList.remove('no-opp-2x'); }catch(_){}
    svg.style.width  = '100%';
    svg.style.height = '100%';
    container.style.overflow  = 'hidden';
    container.style.overflowX = 'hidden';
    container.style.overflowY = 'hidden';
}


// ===== (PATCH) Snap scroll when switching between scrollable/non-scrollable modes =====
try{
  const c = container;
  if(c){
    const rx = (c.scrollWidth||0) - (c.clientWidth||0);
    const ry = (c.scrollHeight||0) - (c.clientHeight||0);
    const hasScroll = (rx > 2) || (ry > 2);

    // Decide axis: follow opp-x/opp-y if present; else fallback to larger range
    const axis = c.classList.contains('opp-x') ? 'x'
              : c.classList.contains('opp-y') ? 'y'
              : (ry >= rx ? 'y' : 'x');

    const prev = c.dataset.__prevScrollMode || '';
    const now  = hasScroll ? ('S-' + axis) : 'N';

    if(prev !== now){
      c.dataset.__prevScrollMode = now;

      
      

// __MODECHANGE_FORCE_PAUSE_SCROLL_V1__
// If after mode change the container becomes scrollable, force system pause to guarantee correct content alignment.
try{
  const __c = c;
  const __snapToPending = ()=>{
    try{
      if(window.__pendingScroll!=null && window.__tryApplyScrollAnchor){
        window.__tryApplyScrollAnchor(window.__pendingScroll, false);
      }else{
        __c && __c.scrollTo && __c.scrollTo({left:0, top:0, behavior:'auto'});
      }
    }catch(_ ){}
  };
  requestAnimationFrame(()=>requestAnimationFrame(()=>{
    setTimeout(()=>{
      // re-measure after settle
      const rx = (__c.scrollWidth||0) - (__c.clientWidth||0);
      const ry = (__c.scrollHeight||0) - (__c.clientHeight||0);
      const hasScroll = (rx>2)||(ry>2);

      __snapToPending();

      if(hasScroll){
        // force pause if currently playing; then keep locked (video mode)
        try{
          if((window.svgIsPlaying||window.ttsIsPlaying) && typeof window.togglePlay === 'function') {
            window.togglePlay(); // pause -> dashed outline
          } else if(typeof window.showPauseCue === 'function') {
            window.showPauseCue();
          }
        }catch(_ ){}
        try{ window.__psSetScrollFree && window.__psSetScrollFree(false); }catch(_ ){}
      }else{
        try{ window.__psSetScrollFree && window.__psSetScrollFree(false); }catch(_ ){}
      }
    }, 450);
  }));
}catch(_ ){}
try{ window.__autoPauseLayoutOnce && window.__autoPauseLayoutOnce(); }catch(_){ }
if(!hasScroll){
        // No scroll: reset to start to avoid "missing content"
        try{ c.scrollTo({left:0, top:0, behavior:'auto'}); }catch(_){}
      }else{
        // Became scrollable or axis changed: snap to scripted anchor if available
        const ds = (window.__pendingScroll != null) ? parseFloat(window.__pendingScroll) : NaN;
        const k  = isFinite(ds) ? Math.max(0, Math.min(1, ds/2)) : 0; // 0,1,2 -> 0,0.5,1
        if(axis === 'x' && rx > 2){
          try{ c.scrollTo({ left: rx * k, behavior:'auto' }); }catch(_){}
        }else if(axis === 'y' && ry > 2){
          try{ c.scrollTo({ top:  ry * k, behavior:'auto' }); }catch(_){}
        }else{
          try{ c.scrollTo({left:0, top:0, behavior:'auto'}); }catch(_){}
        }
      }
    }
  }
}catch(_){}



// __ENTER_OPP_NOSPLIT_FORCEPAUSE_V1__
// When entering opposite (trái chiều) + noSplit scrollable mode, snap to pending data-scroll and force system pause.
try{
  const c = container;
  if(c){
    const isOpp = c.classList.contains('opp-x') || c.classList.contains('opp-y');
    const noSplit = !!window.__noSplit;
    const rx = (c.scrollWidth||0) - (c.clientWidth||0);
    const ry = (c.scrollHeight||0) - (c.clientHeight||0);
    const hasScroll = (rx>2)||(ry>2);
    const nowKey = (isOpp && noSplit && hasScroll) ? 'oppNoSplitScroll' : 'other';
    const prevKey = c.dataset.__prevEnterKey || '';
    c.dataset.__prevEnterKey = nowKey;

    if(prevKey !== nowKey && nowKey === 'oppNoSplitScroll'){
      requestAnimationFrame(()=>requestAnimationFrame(()=>{
        setTimeout(()=>{
          try{
            if(window.__pendingScroll!=null && window.__tryApplyScrollAnchor){
              window.__tryApplyScrollAnchor(window.__pendingScroll, false);
            }
          }catch(_ ){}
          try{
            if((window.svgIsPlaying||window.ttsIsPlaying) && typeof window.togglePlay==='function'){
              window.togglePlay(); // pause
            } else if(typeof window.showPauseCue==='function') {
              window.showPauseCue();
            }
          }catch(_ ){}
          try{ window.__psSetScrollFree && window.__psSetScrollFree(false); }catch(_ ){}
        }, 450);
      }));
    }
  }
}catch(_ ){}
}

  function hook(){
    // Make sure container fills viewport to avoid tiny svg due to small container
    const container = document.getElementById('svgContainer') || document.querySelector('#svgContainer');
    if(container){
      container.style.width = '100vw';
      container.style.height = '100vh';
      /* container.style.overflow = 'hidden';  // (patched) allow CSS to control overflow for scroll anchors */
    }

    const observer = new MutationObserver((mutations)=>{
      for(const m of mutations){
        for(const node of m.addedNodes){
          if(node && node.nodeType === 1){
            let svg = null;
            if(node.tagName && node.tagName.toLowerCase() === 'svg') {
              svg = node;
            } else if (node.querySelector) {
              svg = node.querySelector('svg');
            }
            if(svg){
              setTimeout(()=>{
                ensureSizing(svg);

                // Seed original viewBox
                let vbStr = (svg.getAttribute('viewBox') || '').trim();
                if (!vbStr){
                  const tight = computeTightViewBox(svg);
                  if (tight){
                    vbStr = tight.join(' ');
                    svg.setAttribute('viewBox', vbStr);
                  }
                }
                if (vbStr) originalViewBox = vbStr.split(/[, ]+/).map(Number);

                // Patch orientation function (if any)
                window.applyOrientation = function(){ updateLayout(svg); };

                updateLayout(svg);
                window.addEventListener('resize', ()=>updateLayout(svg));
              }, 0);
            }
          }
        }
      }
    });
    if(container) observer.observe(container, {childList:true, subtree:true});

    // If SVG already present
    const existing = container && container.querySelector('svg');
    if(existing){
      setTimeout(()=>{
        ensureSizing(existing);
        let vbStr = (existing.getAttribute('viewBox') || '').trim();
        if (!vbStr){
          const tight = computeTightViewBox(existing);
          if (tight){
            vbStr = tight.join(' ');
            existing.setAttribute('viewBox', vbStr);
          }
        }
        if (vbStr) originalViewBox = vbStr.split(/[, ]+/).map(Number);
        window.applyOrientation = function(){ updateLayout(existing); };
        updateLayout(existing);
        window.addEventListener('resize', ()=>updateLayout(existing));
      }, 0);
    }
  }

  if(document.readyState !== 'loading') hook();
  else document.addEventListener('DOMContentLoaded', hook);
})();
</script>

<style>
  /* Make SVG <a class="link"> clickable and look like links */
  svg a.link { cursor: pointer; pointer-events: all; }
  /* Overlay dialog */
  #dlgOverlay{width:100vw; height:100vh;
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.45); z-index:9999;
  }
  #dlgCard{
    background:#111; color:#fff; width:80vw ;height:80vh; overflow:auto;
    border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35); padding:20px;
    font-family:system-ui,Segoe UI,Arial;
  }
  #dlgCard h3{ margin:0 0 10px; font-size:20px; line-height:1.4 }
  #dlgContent{ white-space:normal; line-height:1.6; }

  #dlgCard iframe{ width:90vw; height:90vh; border:0; border-radius:12px; background:#000; }
  #dlgCard img, #dlgCard video{ max-width:80%; max-height:80vh; display:block; margin:auto; }
/* Popup overlay giữ nguyên */
#dlgOverlay{width:100vw; height:100vh;
  position:fixed; inset:0; display:none; align-items:center; justify-content:center;
  background:rgba(0,0,0,.45); z-index:9999;
}

/* Cho card gần full màn hình + bỏ padding để nội dung 100% */
#dlgCard{
  background:#111; color:#fff;
  width:90vw; height:90vh;               /* to hơn 80vw/80vh */
  border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.35);
  padding:0;                              /* QUAN TRỌNG: bỏ padding */
  display:flex; flex-direction:column;    /* để #dlgContent fill */
  overflow:hidden;                        /* scroll nằm trong nội dung */
  font-family:system-ui,Segoe UI,Arial;
}

/* Tiêu đề (nếu cần) có thể ẩn hoặc để mỏng */
#dlgCard h3{ margin:0; padding:10px 14px; font-size:18px; line-height:1.3; display:none; }

/* Vùng nội dung fill 100% card */
#dlgContent{
  flex:1; min-height:0;                   /* cho phép con cao 100% */
  display:flex; align-items:stretch; justify-content:stretch;
}

/* Mọi iframe/object bên trong chiếm 100% vùng nội dung */
#dlgContent iframe,
#dlgContent object{
  width:100%; height:100%;
  border:0; border-radius:0; background:#fff;
  display:block;
}

/* Ảnh/video cũng fill hợp lý (giữ tỉ lệ) */
#dlgContent img, 
#dlgContent video{
  max-width:100%; max-height:100%;
  width:100%; height:100%;
  object-fit:contain; display:block; margin:0;
}
</style>

<div id="dlgOverlay" aria-hidden="true">
  <div id="dlgCard" role="dialog" aria-modal="true">
    <h3>Nội dung</h3>
    <div id="dlgContent">...</div>
  </div>
</div>

<script>
(function(){
  let lastCueEl = null; // optional: element to resume if needed

  function renderContent(src){
    if(!src) return '...';
    if(/[<>]/.test(src)) return src;

    if(/\.(png|jpe?g|gif|webp|svg)$/i.test(src)) return `<img src="${src}" alt="">`;
    if(/\.(mp4|webm|ogg)$/i.test(src)) return `<video src="${src}" controls></video>`;

    // HTML/PDF → object full popup
    if(/^https?:\/\//i.test(src) || /\.(html?|pdf)$/i.test(src)){
      const type = /\.pdf$/i.test(src) ? "application/pdf" : "text/html";
      return `<div style="width:100%;height:100%;">
                <object data="${src}" type="${type}" width="100%" height="100%">
                  Không tải được nội dung.
                </object>
              </div>`;
    }
    return String(src).replace(/\n/g,'<br>');
  }

  window.showDialog = function(src, resumeEl){
    // Ghi nhớ trạng thái đang chạy trước khi autoPause
    try{
      window.__dialogWasPlaying = !!(window.svgIsPlaying || window.ttsIsPlaying);
    }catch(_){
      window.__dialogWasPlaying = false;
    }

    // Tự động tạm dừng TTS + SVG + nhạc
    try{ window.autoPause && window.autoPause('link'); }catch(_){}

    lastCueEl = resumeEl || lastCueEl || null;
    const overlay = document.getElementById('dlgOverlay');
    const content = document.getElementById('dlgContent');
    content.innerHTML = renderContent(src);
    overlay.style.display = 'flex';
    overlay.setAttribute('aria-hidden','false');

    function close(){
      overlay.style.display = 'none';
      overlay.setAttribute('aria-hidden','true');
      try{
        if(lastCueEl){
          // Nếu có cue chờ sẵn (ví dụ [D0]), ưu tiên click nó
          lastCueEl.dispatchEvent(new Event('click', {bubbles:true}));
          lastCueEl = null;
        }else if(window.__dialogWasPlaying && typeof togglePlay === 'function'){
          // Nếu trước khi mở popup bài đang chạy, đóng popup cho chạy tiếp
          togglePlay();
        }else if(window.tl && tl.resume){
          // Dự phòng: chỉ có timeline
          tl.resume();
          if(window.showPlayCue) showPlayCue();
          window.svgIsPlaying = true;
        }
      }catch(_){}
      window.__dialogWasPlaying = false;
    }

    overlay.addEventListener('click', (e)=>{
      if(e.target === overlay){ // click vùng tối bên ngoài
        close();
      }
    });

    overlay.onkeydown = (e)=>{
      if(e.key==='Enter' || e.key==='Escape'){ e.preventDefault(); close(); }
    };
  };

  window.closeDialog = function(){
    const overlay = document.getElementById('dlgOverlay');
    if(overlay) overlay.style.display='none';
  };

  document.addEventListener('click', (e)=>{
    const a = e.target.closest && e.target.closest('a.link');
    if(!a) return;
    e.preventDefault();
    const src = a.getAttribute('data-src') || a.getAttribute('href') || '';
    showDialog(src);
  }, true);
})();
</script>

<script>
(function(){
  try{
    const _origPT = window.processText;
    if(typeof _origPT === 'function'){
      window.processText = function(text){
        const regex = /\[(.*?)\]/g;
        if(/\[POP\s*:.+?\]/i.test(text) && String(_origPT).indexOf('[POP') === -1){
          const segs = [];
          let lastIndex = 0, m;
          while((m = regex.exec(text))){
            const head = text.substring(lastIndex, m.index);
            if(head.trim()) segs.push({text: head});
            const inner = (m[1]||'').trim();
            const tag = inner.split(':',1)[0].trim().toUpperCase();
            if(tag === 'POP'){
              const src = inner.slice(tag.length+1).trim();
              if(src) segs.push({popup: src});
            }else{
              segs.push({text: '['+inner+']'});
            }
            lastIndex = regex.lastIndex;
          }
          segs.push({text: text.substring(lastIndex)});

          const rejoined = segs.map(s => s.text || '').join('');
          const parsed = _origPT(rejoined);
          const out = [];
          let tIndex = 0;
          for(const s of segs){
            if(s.popup){
              out.push({text:null, popup:s.popup});
            }else if(s.text){
              if(tIndex < parsed.length){
                let p = parsed[tIndex++];
                if(p && (p.text || p.delay || p.waitClick)){
                  out.push(p);
                }
              }
            }
          }
          while(tIndex < parsed.length){ out.push(parsed[tIndex++]); }
          return out;
        }
        return _origPT.apply(this, arguments);
      };
    }

    const _origSP = window.speakPart;
    if(typeof _origSP === 'function'){
      window.speakPart = function(){
        try{
          if(window.ttsSegments && window.currentPart != null){
            const part = window.ttsSegments[window.currentPart];
            if(part && part.popup){
              if(typeof window.showDialog === 'function'){
                try{ window.showDialog(part.popup); }catch(e){}
              }
              window.currentPart++;
              return _origSP.apply(this, arguments);
            }
          }
        }catch(e){}
        return _origSP.apply(this, arguments);
      };
    }
  }catch(e){}
})();
</script>

<!-- ==== CLEAN TTS FUNCTIONS FIXED (đã thêm showPlayCue/showPauseCue) ==== -->
<script>
// Helpers
function _isMobile(){ return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent); }
function _resumeDelay(){ return (typeof RESUME_DELAY_MS==='number'?RESUME_DELAY_MS:120); }
function _clampCharIndexToPart(idx){
  try{ const p=ttsSegments&&ttsSegments[currentPart]; if(p&&typeof p.text==='string'){ const L=p.text.length|0;
    if(idx>=L) return Math.max(0,L-1); if(idx<0) return 0; } }catch(_){ }
  return Math.max(0,idx|0);
}

// Parse text from [R..][P..][V..][D0][Dn][POP:...]
function processText(text){
  const regex=/\[(.*?)\]/g; let res,lastIndex=0,segs=[],rate=1,pitch=1,volume=1;
  function pushPlain(s){ if(s&&s.trim()) segs.push({text:s,rate,pitch,volume,delay:0}); }
  while((res=regex.exec(text))){
    pushPlain(text.substring(lastIndex,res.index));
    const raw=(res[1]||"").trim(); const TAG=raw.split(':',1)[0].trim().toUpperCase(); const VAL=raw.slice(TAG.length+1).trim();
    if(TAG==='POP'){ if(VAL) segs.push({text:null,popup:VAL}); }
    else if(TAG.startsWith('R')) rate=parseFloat(raw.slice(1))||1;
    else if(TAG.startsWith('P')) pitch=parseFloat(raw.slice(1))||1;
    else if(TAG.startsWith('V')) volume=parseFloat(raw.slice(1))||1;
    else if(TAG==='D'||TAG.startsWith('D')){ const numStr=raw.slice(1).trim();
      if(numStr===""){
        // [D] → TTS dừng vô hạn, SVG vẫn chạy
        segs.push({text:null,waitClick:"tts"});
      }else{
        const num=parseInt(numStr,10);
        if(!isNaN(num)){
          if(num===0){
            // [D0] → dừng cả TTS + SVG, chờ click
            segs.push({text:null,waitClick:"both"});
          }else if(num>0){
            // [Dn] → TTS dừng n giây, SVG vẫn chạy
            segs.push({text:null,delay:num*1000});
          }
        }
      }
    }
    lastIndex=regex.lastIndex;
  }
  pushPlain(text.substring(lastIndex)); return segs;
}

// Init TTS segments from SVG
function initTtsSegments(){
  const el=document.getElementById('tts-audio'); if(el){ ttsSegments=processText(el.getAttribute('data-text')||el.textContent||""); currentPart=0; charIndex=0; return true; }
  return false;
}

// Speak part
function speakPart(){
  if(!ttsIsPlaying) return;
  if(currentPart>=ttsSegments.length){ ttsIsPlaying=false; try{showPlayCue&&showPlayCue();}catch(_){ }
    try{ if(!svgIsPlaying&&typeof stopBgMusicIfAllDone==='function') stopBgMusicIfAllDone(); }catch(_){ }
    return; }
  const part=ttsSegments[currentPart];
  if(part&&part.popup){ try{showDialog&&showDialog(part.popup);}catch(_){ }
    currentPart++; charIndex=0; speakPart(); return; }
  if(part&&part.waitClick){ 
    const mode = part.waitClick;
    // Chuẩn bị resume TTS sau này (sau khi được "mở khóa")
    ttsResumeState = {part:currentPart+1, char:0}; 
    try{ speechSynthesis.cancel(); }catch(_){}

    if(mode==="tts"){
      // [D] → TTS dừng, chờ data-play="0" trên SVG; SVG vẫn chạy
      ttsSyncWait = true;
      ttsIsPlaying = false;
      // KHÔNG đụng tl, KHÔNG dùng waitingForClick
      return;
    }else if(mode==="both"){
      // [D0] → giải phóng chờ của SVG (nếu có), TTS chỉ lướt qua marker
      if(svgSyncWait){
        svgSyncWait = false;
        try{ tl && tl.resume && tl.resume(); svgIsPlaying = true; }catch(_){}
      }
      // Cho TTS tiếp tục ngay phần kế
      currentPart++;
      charIndex = 0;
      speakPart();
      return;
    }else{
      // fallback cũ: dừng cả hai và chờ click
      waitingForClick="both";
      try{tl&&tl.pause&&tl.pause();}catch(_){ }
      try{bgMusic&&!bgMusic.paused&&bgMusic.pause();}catch(_){ }
      svgIsPlaying=false;
      ttsIsPlaying=false; 
      scheduleAutoResume();
      try{ showPauseCue(); }catch(_){ } // thêm hiển thị pause
      return;
    }
  }
  if(part&&part.delay>0){ setTimeout(()=>{currentPart++;charIndex=0;speakPart();},part.delay); return; }
  if(part&&typeof part.text==='string'){ const start=_clampCharIndexToPart(charIndex|0); const rem=part.text.substring(start); if(!rem.trim()){currentPart++;charIndex=0;speakPart();return;}
    const u=new SpeechSynthesisUtterance(rem); utterance=u;
    u.rate=part.rate||1; u.pitch=part.pitch||1; u.volume=part.volume||1;
    u.onboundary=(e)=>{ if(typeof e.charIndex==='number') charIndex=start+e.charIndex; };
    u.onend=()=>{charIndex=0; currentPart++; speakPart();};
    speechSynthesis.speak(u); return; }
  currentPart++; charIndex=0; speakPart();
}

// Resume after [D0]
function resumeAfterWait(){
  const mode = waitingForClick || "both";
  waitingForClick=false;

  // Khôi phục SVG / nhạc nếu từng bị dừng
  if(mode==="both" || mode==="svg"){
    try{bgMusic&&bgMusic.play().catch(()=>{});}catch(_){ }
    try{tl&&tl.resume&&tl.resume();}catch(_){ }
    svgIsPlaying=true;
  }

  try{ showPlayCue(); }catch(_){ } // thêm hiển thị play

  // Khôi phục TTS nếu cần
  if(mode==="both" || mode==="tts"){
    const ss=speechSynthesis, delay=_resumeDelay();
    if(ss&&ss.paused){
      ss.resume(); 
      ttsIsPlaying=true; 
      setTimeout(()=>{ if(!(ss&&ss.speaking)) speakPart(); },delay); 
      return; 
    }
    if(ttsResumeState&&ttsSegments[ttsResumeState.part]){ 
      currentPart=ttsResumeState.part|0; 
      charIndex=_clampCharIndexToPart(ttsResumeState.char||0); 
      ttsResumeState=null; 
    }
    ttsIsPlaying=true; 
    speakPart();
  }
}
// Toggle Play/Pause
function togglePlay(){
  if(!firstUserGestureDone){ if(!ttsSegments||!ttsSegments.length) initTtsSegments(); firstUserGestureDone=true; startBoth(); return; }
  if(waitingForClick){ resumeAfterWait(); return; }
  const ss=speechSynthesis, delay=_resumeDelay();
  if(tl&&tl.paused&&tl.paused()){ try{bgMusic&&bgMusic.play().catch(()=>{});}catch(_){ }
    try{tl.resume();}catch(_){ }
    svgIsPlaying=true; ttsIsPlaying=true;
    try{ showPlayCue(); }catch(_){ } // thêm hiển thị play

    if(ss&&ss.paused){ ss.resume(); setTimeout(()=>{ if(!(ss&&ss.speaking)) speakPart(); },delay); }
    else speakPart(); return; }
  if(svgIsPlaying||ttsIsPlaying){ ttsResumeState={part:currentPart,char:_clampCharIndexToPart(charIndex)}; if(_isMobile()) ss.cancel(); else if(ss.speaking&&ss.pause) ss.pause();
    try{bgMusic&&bgMusic.pause();}catch(_){ }
    try{tl&&tl.pause();}catch(_){ }
    waitingForClick=true; svgIsPlaying=false; ttsIsPlaying=false; 
    try{ showPauseCue(); }catch(_){ } // thêm hiển thị pause
    return; }
  if(ttsResumeState&&ttsSegments[ttsResumeState.part]){ startBoth(); currentPart=ttsResumeState.part; charIndex=_clampCharIndexToPart(ttsResumeState.char||0); ttsResumeState=null; ttsIsPlaying=true; setTimeout(()=>{if(!(ss&&ss.speaking)) speakPart();},delay); }
  else{ if(!ttsSegments||!ttsSegments.length) initTtsSegments(); startBoth(); }
}
</script>

<script>
// ===== One-Tap Mobile TTS Unlock (sync first play with TTS) =====
(function(){
  if (window.__oneTapInstalled) return; 
  window.__oneTapInstalled = true;

  function _isMobile(){
    return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  }

  function pickVi(){
    try{
      var vs = window.speechSynthesis ? (window.speechSynthesis.getVoices() || []) : [];
      return vs.find(function(v){ return (v.lang||'').toLowerCase() === 'vi-vn'; })
          || vs.find(function(v){ return /(^|[-_])vi($|[-_])/i.test(v.lang||''); })
          || vs.find(function(v){ return /vietnam/i.test(v.name||''); })
          || null;
    }catch(e){ return null; }
  }

  function unlockTTS(cb){
    try{
      try{ window.speechSynthesis && window.speechSynthesis.getVoices(); }catch(_){}
      var tries = 0;
      (function ensureVoices(){
        var vs = (window.speechSynthesis && window.speechSynthesis.getVoices()) || [];
        if (vs.length || tries > 40){
          try{
            var u = new SpeechSynthesisUtterance(" ");
            var v = pickVi();
            if (v) { try{ u.voice = v; }catch(_){} }
            u.lang   = (v && v.lang) || "vi-VN";
            u.volume = 0;
            u.rate   = 1;
            u.pitch  = 1;

            var done = function(){ cb && cb(); };
            u.onend   = done;
            u.onerror = done;
            u.onstart = function(){ setTimeout(done, 30); };

            try{ window.speechSynthesis.cancel(); }catch(_){}
            setTimeout(function(){
              try{ window.speechSynthesis.speak(u); }catch(_){ done(); }
            }, 0);
          }catch(e){ cb && cb(); }
          return;
        }
        tries++;
        setTimeout(ensureVoices, 50);
      })();
    }catch(e){ cb && cb(); }
  }

  // Wrap togglePlay: only intercept first tap on mobile
  try{
    var _toggle = window.togglePlay;
    if (typeof _toggle === 'function'){
      window.togglePlay = function(){
        // PC / non-mobile: giữ nguyên hành vi cũ
        if (!_isMobile()){
          return _toggle.apply(this, arguments);
        }

        // Lần chạm đầu trên mobile: unlock TTS rồi mới gọi togglePlay gốc
        if (!window.__mobileTtsUnlocked){
          window.__mobileTtsUnlocked = true;
          unlockTTS(function(){
            try{
              _toggle();
            }catch(_){}
          });
          return;
        }

        // Các lần sau: dùng togglePlay gốc bình thường
        return _toggle.apply(this, arguments);
      };
    }
  }catch(_){}
})();
</script>


<!-- === FINAL (fix initial load, ensure part2 visible, ON scroll+zoom, OFF translate) === -->

<script>
// Global: OFF by default
window.__noSplit = false;

// === PATCH: reset scroll + clear Opposite state when switching modes ===
function __resetScrollAndOppState(){
  try{
    const c = document.getElementById('svgContainer');
    if(!c) return;
    try{ c.scrollLeft = 0; }catch(_){}
    try{ c.scrollTop  = 0; }catch(_){}
    try{ c.classList.remove('opp-x','opp-y','no-opp-2x'); }catch(_){}
    try{
      c.style.overflow  = 'hidden';
      c.style.overflowX = 'hidden';
      c.style.overflowY = 'hidden';
    }catch(_){}
    const svg = c.querySelector('svg');
    if(svg){
      try{
        svg.style.width  = '100%';
        svg.style.height = '100%';
        svg.style.maxWidth = 'none';
        svg.style.maxHeight = 'none';
      }catch(_){}
    }
  }catch(_){}
}

(function(){
  // --- Toggle button ---
  function ensureBtn(){
    if (document.getElementById('noToggleBtn')) return;
    const btn = document.createElement('button');
    btn.id = 'noToggleBtn'; btn.type = 'button';
    btn.classList.add('adaptiveBtn');
    Object.assign(btn.style, {
      position:'fixed', left:'17px', top:'17px', zIndex:9999
    });
   function refreshNoToggle(){
  const btn = document.getElementById('noToggleBtn');
  btn.innerHTML = window.__noSplit ? '&#9636;' : '&#9637;';
}

     
    btn.addEventListener('click', ()=>{
      const _prev = !!window.__noSplit;
      window.__noSplit = !window.__noSplit;
      // If switching FROM slide (noSplit=true) -> split (noSplit=false), reset scroll (page2 -> page1)
      if(_prev && !window.__noSplit){ try{ __resetScrollAndOppState(); }catch(_){} }
      refreshNoToggle();
      safeApply();
    });
    document.body.appendChild(btn); refreshNoToggle();
  }

  // --- Helpers ---
  function qs(s, c){ return (c||document).querySelector(s); }
  function wrap(){ return qs('#svgContainer') || document.body; }
  function svgEl(){ return qs('#svgContainer svg') || qs('svg'); }

  // Capture baseline once the SVG is really there
  function captureBaseline(svg){
    if (!svg.__baselineFix){
      let vbStr = (svg.getAttribute('viewBox') || '').trim();
      if (!vbStr){
        const b = svg.viewBox && svg.viewBox.baseVal;
        vbStr = b ? [b.x,b.y,b.width,b.height].join(' ') : '0 0 100 100';
        svg.setAttribute('viewBox', vbStr);
      }
      const vb = vbStr.split(/[, ]+/).slice(0,4).map(Number);
      const p1 = svg.querySelector('#part1');
      const p2 = svg.querySelector('#part2');
      svg.__baselineFix = {
        vb,
        t1: p1 && p1.getAttribute('transform') || null,
        t2: p2 && p2.getAttribute('transform') || null,
        cssW: svg.style.width || '',
        cssH: svg.style.height || ''
      };
      window.originalViewBox = vb.slice();
    }
    return svg.__baselineFix;
  }

  function restoreBaseline(svg){
    const base = captureBaseline(svg);
    const [x,y,w,h] = base.vb;
    svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
    svg.style.width  = base.cssW;
    svg.style.height = base.cssH;
    const p1 = svg.querySelector('#part1');
    const p2 = svg.querySelector('#part2');
    // Ensure visibility (fix first-load "missing part2")
    [p1,p2].forEach(el=>{
      if (!el) return;
      if (base[ el===p1 ? 't1' : 't2' ]!=null) el.setAttribute('transform', base[ el===p1 ? 't1' : 't2' ]);
      else el.removeAttribute('transform');
      el.style.removeProperty('display');
      el.style.removeProperty('visibility');
      el.style.removeProperty('opacity');
      el.style.pointerEvents = 'auto';
    });
  }

  function applyLayout(){
  	
    const svg = svgEl(); const wwrap = wrap(); if (!svg) return;
    const base = captureBaseline(svg); const [x,y,w,h] = base.vb;

    // Reset
    restoreBaseline(svg);
    wwrap.style.overflowX='hidden'; wwrap.style.overflowY='hidden';

    const isScreenPortrait = window.innerHeight > window.innerWidth;
    const isSvgPortrait    = h > w;
    const part2 = svg.querySelector('#part2');
    const isTraiChieu = (!isScreenPortrait && isSvgPortrait) || (isScreenPortrait && !isSvgPortrait);



    if (!isTraiChieu || !part2){
      svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
      part2 && part2.removeAttribute('transform');
      return;
    }

    if (window.__noSplit){
      // ON: scroll-only + zoom (axes swapped per your rule)
      svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
      if (!isScreenPortrait && isSvgPortrait){
        // landscape screen + portrait svg -> VERTICAL scroll
        wwrap.style.overflowY='auto'; wwrap.style.overflowX='hidden';
        wwrap.style.height = '100vh';
        svg.style.height='200%'; svg.style.width='100%';
      } else if (isScreenPortrait && !isSvgPortrait){
        // portrait screen + landscape svg -> HORIZONTAL scroll
        wwrap.style.overflowX='auto'; wwrap.style.overflowY='hidden';
        wwrap.style.height = '100vh';
        svg.style.width='200%'; svg.style.height='100%';
      }
    } else {
      // OFF: translate + fit one frame
      if (!isScreenPortrait && isSvgPortrait){
        svg.setAttribute('viewBox', `${x} ${y} ${2*w} ${h/2}`);
        part2.setAttribute('transform', `translate(${w}, ${-h/2})`);
      } else if (isScreenPortrait && !isSvgPortrait){
        svg.setAttribute('viewBox', `${x} ${y} ${w/2} ${2*h}`);
        part2.setAttribute('transform', `translate(${-w/2}, ${h})`);
      }
      svg.style.width='100%'; svg.style.height='100%';
    }
  }

  function safeApply(){ try{ applyLayout(); }catch(e){ console.warn('applyLayout failed', e); } }

  // Ensure we run *after* the SVG element is inserted
  function waitForSvgAndApply(retryMs=50, maxTries=200){
    let tries=0;
    (function loop(){
      const svg = svgEl();
      if (svg){
        captureBaseline(svg); // prime baseline once
        safeApply();
        return;
      }
      if (tries++ < maxTries) { setTimeout(loop, retryMs); }
    })();
  }

  // Also observe DOM in case the app injects SVG later
  const mo = new MutationObserver(()=>{ const s = svgEl(); if (s && !s.__baselineFix) { captureBaseline(s); safeApply(); } });
  mo.observe(document.documentElement, { childList:true, subtree:true });

  // Hooks
  document.addEventListener('DOMContentLoaded', ()=>{ ensureBtn(); waitForSvgAndApply(); });
  window.addEventListener('load', safeApply);
  window.addEventListener('resize', safeApply);
  window.applyOrientation = safeApply;
  window.updateLayout = safeApply;
})();

</script>

<!-- === Injected: Overlay Highlight (white) + hue=z-index; keep animations intact === -->
<script>
(function(){
  const DRAW = new Set(['path','line','polyline','polygon','rect','circle','ellipse','text','image']);
  const isHL = el => (el.getAttribute('data-type')||'').toLowerCase()==='highlight';
  const isSP = el => (el.getAttribute('data-type')||'').toLowerCase()==='split';

  function ensureOverlay(baseSvg){
    const host = document.getElementById('svgContainer') || baseSvg.parentNode || document.body;
    let ov = document.getElementById('hlOverlaySvg');
    if(!ov){
      ov = document.createElementNS('http://www.w3.org/2000/svg','svg');
      ov.id = 'hlOverlaySvg';
      Object.assign(ov.style, {
        position:'absolute', inset:'0', pointerEvents:'none',
        filter:'none', mixBlendMode:'normal', zIndex: 9
      });
      if(getComputedStyle(host).position==='static'){ host.style.position='relative'; }
      host.appendChild(ov);
    }
    const vb = baseSvg.getAttribute('viewBox'); if(vb) ov.setAttribute('viewBox', vb);
    function syncSize(){
      const r = baseSvg.getBoundingClientRect();
      ov.setAttribute('width', Math.max(1, Math.round(r.width)));
      ov.setAttribute('height',Math.max(1, Math.round(r.height)));
    }
    syncSize(); addEventListener('resize', ()=>setTimeout(syncSize,50));
    return ov;
  }
  const mtx = m => 'matrix('+[m.a,m.b,m.c,m.d,m.e,m.f].join(' ')+')';

  function setupHighlightOverlay(baseSvg){
    const overlay = ensureOverlay(baseSvg);
    while(overlay.firstChild) overlay.removeChild(overlay.firstChild);
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    overlay.appendChild(g);

    const map = new Map();
    baseSvg.querySelectorAll('[data-type="highlight"]').forEach(src=>{
      try{
        const c = src.cloneNode(true);
        c.setAttribute('fill','#ffffff'); // pure white eraser
        c.setAttribute('stroke','none');
        c.setAttribute('opacity','0');    // opacity synced per-frame
        c.removeAttribute('filter');
        c.style.filter = 'none';
        c.style.mixBlendMode = 'normal';
        const t = src.getCTM && src.getCTM();
        if(t) c.setAttribute('transform', mtx(t));
        g.appendChild(c);
        map.set(src, c);
      }catch(_){}
    });

    // hue as z-index
    const kids = Array.from(g.children);
    const ord = new Map(kids.map((e,i)=>[e,i]));
    const hue = e => parseInt((e.getAttribute('data-hue')||'0'),10)||0;
    kids.sort((a,b)=> (hue(a)-hue(b)) || (ord.get(a)-ord.get(b)));
    kids.forEach(e=>{ try{ g.appendChild(e); }catch(_){ } });

    // sync opacity & transform with original elements
    const sync = ()=>{
      map.forEach((clone, src)=>{
        try{
          const op = parseFloat(src.style.opacity || getComputedStyle(src).opacity || '0') || 0;
          clone.setAttribute('opacity', String(op));
          const t = src.getCTM && src.getCTM();
          if(t) clone.setAttribute('transform', mtx(t));
        }catch(_){}
      });
    };
    if (window.gsap && gsap.ticker) {
      const cb = ()=>sync();
      gsap.ticker.add(cb);
      overlay.__gsapSync = cb;
    } else {
      let rafId = 0;
      (function loop(){ sync(); rafId = requestAnimationFrame(loop); })();
      overlay.__raf = rafId;
    }
  }

  function reorderDomByHue(svg){
    try{
      const parents = [svg, ...svg.querySelectorAll('g')];
      parents.forEach(p=>{
        const kids = Array.from(p.children).filter(n=>{
          const t = (n.tagName||'').toLowerCase();
          return n.nodeType===1 && DRAW.has(t);
        });
        if(kids.length<=1) return;
        const orig = new Map(kids.map((e,i)=>[e,i]));
        const hue = e => parseInt((e.getAttribute('data-hue')||'0'),10)||0;
        const typ = e => (e.getAttribute('data-type')||'').toLowerCase();

        kids.sort((a,b)=>{
          const ta=typ(a), tb=typ(b);
          if(ta==='split'||tb==='split') return orig.get(a)-orig.get(b); // keep split order
          const ha=hue(a), hb=hue(b);
          return (ha!==hb) ? (ha-hb) : (orig.get(a)-orig.get(b));
        });
        kids.forEach(e=>{ try{ p.appendChild(e); }catch(_){ } });
      });
    }catch(_){}
  }

  function recolorNearBlack(svg, hex='#111'){
    svg.querySelectorAll('*').forEach(el=>{
      try{
        if(isHL(el) || isSP(el)) return;
        const tag = (el.tagName||'').toLowerCase();
        const dt  = (el.getAttribute('data-type') || '').toLowerCase();
        // bỏ qua các rect đặc biệt: eraser/mask/rect-grey (không đổi màu fill)
        if (dt === 'eraser' || dt === 'mask' || dt === 'rect-grey') return;
        // DATA-FILL addon: do not recolor pattern overlays (keep fill=url(#pat...))
        try{ if((el.getAttribute('data-nodraw')||'')==='1') return; }catch(_){ }
        try{ const __f=(el.getAttribute('fill')||'').trim(); if(/^url\(/i.test(__f)) return; }catch(_){ }

        // NOTE role: do not recolor/normalize
        try{ const __r=(el.getAttribute('data-role') || (el.closest && el.closest('[data-role]') && el.closest('[data-role]').getAttribute('data-role')) || '').toLowerCase(); if(__r==='note') return; }catch(_){ }
        if(!DRAW.has(tag)) return;
        const cs = getComputedStyle(el);
        let stroke = (el.getAttribute('stroke') || cs.stroke || '').trim().toLowerCase();
        let fill   = (el.getAttribute('fill')   || cs.fill   || '').trim().toLowerCase();

        const isPureBlack = v =>
          v === 'black' ||
          v === '#000' ||
          v === 'rgb(0, 0, 0)' ||
          v === 'rgba(0, 0, 0, 1)';

        const isGray = v =>
          v === '#808080' ||
          v === 'rgb(128, 128, 128)' ||
          v === 'rgba(128, 128, 128, 1)';

        // Chuyển mọi màu có brightness ~0.5 thành xám (#808080)
        const parseRgb = v => {
          const m = v.match(/^rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
          return m ? {r:+m[1], g:+m[2], b:+m[3]} : null;
        };
        const parseHex = v => {
          if(!v || v[0] !== '#') return null;
          let hex = v.slice(1);
          if(hex.length === 3){
            hex = hex.split('').map(ch=>ch+ch).join('');
          }
          if(hex.length !== 6) return null;
          const num = parseInt(hex, 16);
          if(!isFinite(num)) return null;
          return {
            r: (num >> 16) & 255,
            g: (num >> 8) & 255,
            b: num & 255
          };
        };
        const getBrightness = v => {
          v = (v || '').trim().toLowerCase();
          if(!v) return null;
          let c = null;
          if(v.startsWith('rgb')) c = parseRgb(v);
          else if(v[0] === '#') c = parseHex(v);
          if(!c) return null;
          const maxC = Math.max(c.r, c.g, c.b);
          return maxC / 255;
        };

        const bStroke = getBrightness(stroke);
        if(bStroke != null && bStroke >= 0.45 && bStroke <= 0.55){
          // ép về xám chuẩn cho mọi màu có độ sáng ~50%
          stroke = '#808080';
          el.style.setProperty('stroke', '#808080', 'important');
        }

        if(fill && fill!=='none' && !isPureBlack(fill)) {
          el.style.setProperty('fill', hex, 'important');
        }
        if(stroke && stroke!=='none' && !isPureBlack(stroke) && !isGray(stroke)) {
          el.style.setProperty('stroke', hex, 'important');
        }
        el.style.filter='none';
        el.style.mixBlendMode='normal';
      }catch(_){}
    });
  }

  window.__FoEnableHighlightOverlay = function(svg){
    try{
      recolorNearBlack(svg, '#111');
      reorderDomByHue(svg);
      setupHighlightOverlay(svg);
    }catch(_){}
  };
})();
</script>

<!-- Band/Row opposite-layout patch v2: preserve paint order to keep overwrite effects -->
<script>
(function(){
  // Avoid double-install
  if (window.__APPLY_BAND_ROW_OPPOSITE_V2__) return;
  window.__APPLY_BAND_ROW_OPPOSITE_V2__ = true;

  function parseSign(val){
    if (val == null) return 0;
    const s = String(val).trim().replace(/\u2212/g,'-');
    if (/^[\-]/.test(s)) return -1;
    if (/^\+/.test(s))   return  1;
    const n = parseFloat(s);
    if (isFinite(n)) return n < 0 ? -1 : 1;
    return 1;
  }

  // Extract raw row/band. Priority: data-row & data-band.
  // If data-band is a combined string like "+04-03": rowRaw=+04, bandRaw=-03.
  function extractRowBandRaw(node){
    let rowRaw  = node.getAttribute && node.getAttribute('data-row');
    let bandRaw = node.getAttribute && node.getAttribute('data-band');

    // Handle combined string in data-band
    if ((!rowRaw || !bandRaw) && typeof bandRaw === 'string'){
      const t = bandRaw.replace(/\s+/g,'').replace(/\u2212/g,'-');
      const m = t.match(/^([+\-]\d+)([+\-]\d+)$/);
      if (m){
        if (!rowRaw)  rowRaw  = m[1];
        if (!bandRaw) bandRaw = m[2];
      }
    }
    return {rowRaw, bandRaw};
  }

  function getRowBandSign(node, want){ // want: 'row' | 'band'
    const {rowRaw, bandRaw} = extractRowBandRaw(node);
    if (want === 'row'){
      if (rowRaw  != null) return parseSign(rowRaw);
      if (bandRaw != null) return parseSign(bandRaw);
    } else {
      if (bandRaw != null) return parseSign(bandRaw);
      if (rowRaw  != null) return parseSign(rowRaw);
    }
    return 1;
  }

  function drawParent(el, svg){
    let cur = el;
    while (cur && cur.parentNode && cur.parentNode !== svg){
      cur = cur.parentNode;
    }
    return cur && cur.parentNode === svg ? cur : el;
  }

  function uniqueInDomOrder(list){
    const seen = new Set(); const out = [];
    list.forEach(n=>{ if (n && !seen.has(n)) { seen.add(n); out.push(n); } });
    return out;
  }

  function ensureVB(svg){
    const vbAttr = (svg.getAttribute('viewBox')||'').trim().split(/[,\s]+/).map(Number);
    if (!svg.__vb0 && vbAttr.length===4 && vbAttr.every(Number.isFinite)){
      svg.__vb0 = {x:vbAttr[0], y:vbAttr[1], w:vbAttr[2], h:vbAttr[3]};
    }
    if (!svg.__vb0){
      const w = (svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal.width  : 1000);
      const h = (svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal.height : 1000);
      svg.__vb0 = {x:0,y:0,w,h};
      svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
    }
    return svg.__vb0;
  }

  function setTranslate(node, dx, dy){
    // Preserve original transform
    if (!node.__origTransformSaved){
      node.__origTransformSaved = true;
      node.__origTransformValue = node.getAttribute('transform') || '';
    }
    const base = node.__origTransformValue || '';
    const translate = (dx || dy) ? `translate(${dx||0} ${dy||0}) ` : '';
    node.setAttribute('transform', translate + base);
  }

  function restoreTransform(node){
    if (node.__origTransformSaved){
      if (node.__origTransformValue) node.setAttribute('transform', node.__origTransformValue);
      else node.removeAttribute('transform');
    }
  }

  function applyBandRowOppositeLayoutImpl(svg, noMode){
    if (!svg) return;
    const VB = ensureVB(svg);
    const isSvgPortrait    = VB.h > VB.w;
    const isScreenPortrait = window.innerHeight > window.innerWidth;
    const opposite = (!noMode) && (isSvgPortrait !== isScreenPortrait);

    // Collect carriers once
    const selBand = '[data-band]';
    const selRow  = '[data-row]';
    const nodes = Array.from(new Set([
      ...Array.from(svg.querySelectorAll(selBand)),
      ...Array.from(svg.querySelectorAll(selRow))
    ]));
    const carriers = uniqueInDomOrder(nodes.map(n => drawParent(n, svg)));

    // Restore transforms & viewBox if not opposite
    if (!opposite){
      carriers.forEach(restoreTransform);
      svg.setAttribute('viewBox', `${VB.x} ${VB.y} ${VB.w} ${VB.h}`);
      svg.setAttribute('preserveAspectRatio','xMidYMid meet');
      return;
    }

    // Opposite: decide axis and offsets
    const useBand = !isSvgPortrait; // landscape -> band vertical split; portrait -> row horizontal split
    const gap = Math.max(4, Math.round(Math.min(VB.w, VB.h) * 0.02));

    // Expand viewBox and compute per-node shifts
    let dxNeg = 0, dyNeg = 0;
    if (useBand){
      // stack vertically: negatives go DOWN
      svg.setAttribute('viewBox', `${VB.x} ${VB.y} ${VB.w} ${VB.h*2 + gap}`);
      dxNeg = 0; dyNeg = VB.h + gap;
    }else{
      // side-by-side: negatives go RIGHT
      svg.setAttribute('viewBox', `${VB.x} ${VB.y} ${VB.w*2 + gap} ${VB.h}`);
      dxNeg = VB.w + gap; dyNeg = 0;
    }

    const wantKind = useBand ? 'band' : 'row';
    carriers.forEach(n=>{
      const sgn = getRowBandSign(n, wantKind);
      if (sgn >= 0){
        // positive: keep place (restore original transform if any)
        restoreTransform(n);
      }else{
        // negative: translate, but KEEP DOM ORDER to preserve overlay effects
        setTranslate(n, dxNeg, dyNeg);
      }
    });

    svg.setAttribute('preserveAspectRatio','xMidYMid meet');
  }

  // Public API
  window.applyBandRowOppositeLayout = function({svg, noMode}){
    try{ applyBandRowOppositeLayoutImpl(svg, !!noMode); }catch(e){ console.error(e); }
  };

  // Auto-run similar to v1 (works if host injects svg later)
  function bootOnce(){
    const svg = (window.svgContainer && svgContainer.querySelector) ? svgContainer.querySelector('svg') : document.querySelector('svg');
    if (!svg) return;
    const params = new URLSearchParams(location.search);
    const noMode = !!( (typeof window.__noSplit!=='undefined' && window.__noSplit) || params.has('no') );
    window.applyBandRowOppositeLayout({svg, noMode});
    window.addEventListener('resize', ()=>{
      const s = (window.svgContainer && svgContainer.querySelector) ? svgContainer.querySelector('svg') : document.querySelector('svg');
      window.applyBandRowOppositeLayout({svg: s, noMode});
    });
  }
  document.addEventListener('DOMContentLoaded', ()=>{
    setTimeout(bootOnce, 0);
    setTimeout(bootOnce, 300);
    setTimeout(bootOnce, 1000);
  });
})();
</script>

<script id="opp-scroll-logic">
(function(){
  function byId(id){ return document.getElementById(id) || document.querySelector('#'+id); }
  const container = byId('svgContainer');
  const svg = container ? container.querySelector('svg') : null;

  function applyOppositeScroll(){
    if (!container || !svg) return;
    // NEW: only enable opposite-scroll in NO (slide) mode
    try{
      var params = new URLSearchParams(location.search);
      var noMode = !!((typeof window.__noSplit!=='undefined' && window.__noSplit) || params.has('no'));
      if(!noMode){
        // Leaving slide mode -> clear opposite state + reset to page 1
        try{ container.classList.remove('opp-x','opp-y','no-opp-2x'); }catch(_){ }
        try{ container.scrollLeft = 0; container.scrollTop = 0; }catch(_){ }
        try{ container.style.overflow='hidden'; container.style.overflowX='hidden'; container.style.overflowY='hidden'; }catch(_){ }
        return;
      }
    }catch(_){ }
    var vbStr = svg.getAttribute('viewBox') || '';
    var vb = vbStr.trim().split(/[, ]+/).map(Number);
    var isSvgPortrait = (vb.length===4) ? (vb[3] > vb[2]) : (window.innerHeight > window.innerWidth);
    var isScreenPortrait = window.innerHeight > window.innerWidth;

    container.classList.remove('opp-x','opp-y');
    if (isScreenPortrait && !isSvgPortrait){
      container.classList.add('opp-x'); // horizontal scroll (svg = 200vw)
    } else if (!isScreenPortrait && isSvgPortrait){
      container.classList.add('opp-y'); // vertical scroll (svg = 200vh)
    }
  }

  // Run on key lifecycle events
  window.addEventListener('resize', applyOppositeScroll);
  window.addEventListener('orientationchange', applyOppositeScroll);
  document.addEventListener('fullscreenchange', applyOppositeScroll, {passive:true});
  window.addEventListener('load', applyOppositeScroll);

  // Expose in case your code wants to trigger it
  window.__applyOppositeScroll = applyOppositeScroll;
  // Initial
  applyOppositeScroll();
})();
</script>

<script id="orig-viewBox-lock">
(function(){
  function byId(id){ return document.getElementById(id) || document.querySelector('#'+id); }
  const container = byId('svgContainer');
  const svg = container ? container.querySelector('svg') : null;

  function ensureOrigViewBox(){
    if (!svg) return;
    var vb = svg.getAttribute('viewBox');
    if (vb && !svg.dataset.origViewBox){
      svg.dataset.origViewBox = vb.trim();  // LƯU GỐC 1 LẦN
    }
  }

  function restoreViewBox(){
    if (!svg) return;
    if (svg.dataset.origViewBox){
      // Trả về đúng viewBox gốc để không lệch phần 1/2 khi đổi chế độ
      svg.setAttribute('viewBox', svg.dataset.origViewBox);
    }
    // Bảo đảm tỉ lệ giữa khung & nội dung ổn định
    svg.setAttribute('preserveAspectRatio','xMidYMid meet');
  }

  // Hook vào logic áp class để luôn restore viewBox trước khi resize
  function wrapApply(){
    const fn = window.__applyOppositeScroll;
    if (!fn) return;
    window.__applyOppositeScroll = function(){
      ensureOrigViewBox();
      restoreViewBox();
      try { return fn.apply(this, arguments); }
      finally {
        // Sau khi đổi kích thước vẫn giữ viewBox gốc
        restoreViewBox();
      }
    };
  }

  // Khởi tạo
  ensureOrigViewBox();
  restoreViewBox();
  wrapApply();

  // Nếu có updateLayout/applyOrientation cũ, cũng chặn lệch bằng restore trước/sau
  ['updateLayout','applyOrientation'].forEach(function(name){
    const f = window[name];
    if (typeof f === 'function'){
      window[name] = function(){
        ensureOrigViewBox(); restoreViewBox();
        try { return f.apply(this, arguments); }
        finally { restoreViewBox(); }
      };
    }
  });

  // Khi load/resize/fullscreen cũng đảm bảo viewBox trở về gốc
  ['load','resize'].forEach(function(evt){
    window.addEventListener(evt, function(){ ensureOrigViewBox(); restoreViewBox(); });
  });
  document.addEventListener('fullscreenchange', function(){ ensureOrigViewBox(); restoreViewBox(); }, {passive:true});
})();
</script>
<script>
// Thiết lập --vh theo visualViewport; cung cấp kích thước chính xác cho code JS
(function(){
  const root = document.documentElement;
  function setVHVar(){
    const vv = window.visualViewport;
    const h = vv ? vv.height : window.innerHeight;
    root.style.setProperty('--vh', (h/100) + 'px');
  }
  setVHVar();
  if (window.visualViewport){
    visualViewport.addEventListener('resize', setVHVar);
    visualViewport.addEventListener('scroll', setVHVar); // bar ẩn/hiện
  }
  window.addEventListener('resize', setVHVar);

  // Kích thước khung nhìn “chuẩn”
  window.__getViewportSizeAccurate = function(){
    if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement){
      return { w: screen.width, h: screen.height }; // chuẩn trong FS
    }
    const vv = window.visualViewport;
    if (vv) return { w: Math.round(vv.width), h: Math.round(vv.height) };
    return { w: innerWidth, h: innerHeight };
  };

  // Hook nhẹ: sau khi layout cũ chạy, đảm bảo center theo kích thước thật
  function tryFinalPass(){
    try{ (window.applyOrientation || window.updateLayout || function(){})(); }catch(_){}
    try{
      if (typeof window.__finalLayoutPass === 'function') window.__finalLayoutPass();
    }catch(_){}
  }
  ['resize','orientationchange','fullscreenchange','webkitfullscreenchange','msfullscreenchange']
    .forEach(ev=>document.addEventListener(ev, tryFinalPass, {passive:true}));

  // Helper căn giữa scroll
  window.__centerContainerAccurate = function(container){
    if (!container) return;
    requestAnimationFrame(()=>{
      try{
        container.scrollLeft = (container.scrollWidth  - container.clientWidth ) / 2;
        container.scrollTop  = (container.scrollHeight - container.clientHeight) / 2;
      }catch(_){}
    });
  };
})();
</script>

<script>
// Nếu bạn có sẵn window.updateLayout, mình “bọc” lại để center chuẩn theo kích thước mới
(function(){
  var origUpdate = window.updateLayout || null;
  window.updateLayout = function(svg){
    if (origUpdate) try{ origUpdate(svg); }catch(_){}
    var c = document.getElementById('svgContainer');
    if (c && window.__centerContainerAccurate) window.__centerContainerAccurate(c);
  };
})();
</script>
<button id="invertToggle" class="adaptiveBtn"></button>

<script>
(function(){
  const btn = document.getElementById('invertToggle');
  if(!btn) return;

  // 1 nút dùng chung:
  //   - Click lẻ  -> toggle SPLIT (reuse noToggleBtn để giữ nguyên logic Nebo)
  //   - Click chẵn-> toggle INVERT (body.invert-mode)
  // Icon theo mod 4:
  //   1 -> &#9636;   (■)
  //   2 -> &#10036;  (✴)
  //   3 -> &#9637;   (□)
  //   0 -> &#9728;   (☀)
  let clickCount = 0;

  // Không dùng title nữa
  try{ btn.removeAttribute('title'); }catch(_){}

  function setIconByMod4(){
    const m = clickCount % 4;
    try{
      if (m === 1) btn.innerHTML = '';
      else if (m === 2) btn.innerHTML = '';
      else if (m === 3) btn.innerHTML = '';
      else btn.innerHTML = ''; // m === 0
    }catch(_){}
  }

  // init icon (clickCount=0)
  setIconByMod4();

  btn.addEventListener('click', () => {
    clickCount++;

    if (clickCount % 2 === 1) {
      // ODD: SPLIT toggle
      const noBtn = document.getElementById('noToggleBtn');
      if (noBtn) {
        noBtn.click();
      } else {
        // fallback (hiếm)
        try { window.__noSplit = !window.__noSplit; } catch(_){}
      }
      setIconByMod4();
      return;
    }

    // EVEN: INVERT toggle
    try{
      const invertOn = !document.body.classList.contains('invert-mode');
      document.body.classList.toggle('invert-mode', invertOn);
    }catch(_){}
    setIconByMod4();
  });
})();;
</script>




<!-- === PATTERN BANK (shared defs) === -->
<svg id="patternBank" width="0" height="0" style="position:absolute; left:-9999px; top:-9999px; opacity:0; pointer-events:none;">
  <defs id="geoDefs">
    <pattern id="patR" patternUnits="userSpaceOnUse" width="4.8" height="4.8">
      <path d="M0.6 0.6 L 4.2 4.2" stroke="#808080" stroke-width="0.6" fill="none"/>
    </pattern>
    <pattern id="patL" patternUnits="userSpaceOnUse" width="4.8" height="4.8">
      <path d="M0.6 4.2 L 4.2 0.6" stroke="#808080" stroke-width="0.6" fill="none"/>
    </pattern>
    <pattern id="patH" patternUnits="userSpaceOnUse" width="4.8" height="4.8">
      <path d="M0 2.4 H 4.8" stroke="#808080" stroke-width="0.5" fill="none"/>
    </pattern>
    <pattern id="patV" patternUnits="userSpaceOnUse" width="4.8" height="4.8">
      <path d="M2.4 0 V 4.8" stroke="#808080" stroke-width="0.5" fill="none"/>
    </pattern>
    <pattern id="patD" patternUnits="userSpaceOnUse" width="4.8" height="4.8">
      <circle cx="2.4" cy="2.4" r="0.6" fill="#808080"/>
    </pattern>
  </defs>
</svg>

<script>
/* === DATA-FILL ADDON (single pattern per closed shape)
   Pattern-rect is ALWAYS present but covered by a mask-rect (same clip).
   The mask-rect uses existing data-type="mask" behavior (1 -> 0), so it disappears đúng thời điểm data-hue.
   -> Giữ nguyên toàn bộ logic khác (stroke timing, sort theo data-hue...) của file gốc.
*/
(function(){
  const NS='http://www.w3.org/2000/svg';

  function ensureDefs(svg){
    if(!svg) return null;
    let defs = svg.querySelector('defs');
    if(!defs){
      defs = document.createElementNS(NS,'defs');
      svg.insertBefore(defs, svg.firstChild);
    }
    return defs;
  }

  function injectPatternDefs(svg){
    if(!svg || svg.__hasGeoDefs) return;
    const bank = document.querySelector('#patternBank #geoDefs');
    if(!bank) return;
    const defs = ensureDefs(svg);
    bank.querySelectorAll('pattern').forEach(p=>{
      const id = p.getAttribute('id');
      if(!id) return;
      try{
        if(svg.querySelector('#'+CSS.escape(id))) return;
      }catch(_){
        if(svg.querySelector('#'+id)) return;
      }
      defs.appendChild(p.cloneNode(true));
    });
    svg.__hasGeoDefs = true;
  }

  function applyDataFill(svg){
    if(!svg) return;
    injectPatternDefs(svg);
    const defs = ensureDefs(svg);

    const vb = (svg.getAttribute('viewBox')||'0 0 210 297').trim().split(/[ ,]+/).map(Number);
    const x=vb[0]||0, y=vb[1]||0, w=vb[2]||210, h=vb[3]||297;

    let k = 0;
    svg.querySelectorAll('[data-fill]').forEach(function(shape){
      const key = (shape.getAttribute('data-fill')||'').trim();
      if(!key) return;
      if(shape.__hasFillOverlay) return;

      // Chỉ xử lý "đường cong kín" (kết thúc bằng Z/z) như bạn mô tả
      try{
        const d = (shape.getAttribute('d')||'').trim();
        if(d && !/[zZ]\s*$/.test(d)) return;
      }catch(_){}

      // clipPath từ chính shape
      const clipId = 'clip_df_' + (Date.now().toString(36)) + '_' + (k++);
      const clip = document.createElementNS(NS,'clipPath');
      clip.setAttribute('id', clipId);

      const clone = shape.cloneNode(true);
      clone.removeAttribute('stroke');
      clone.removeAttribute('stroke-width');
      clone.removeAttribute('fill');
      clone.removeAttribute('data-fill');
      clip.appendChild(clone);
      defs.appendChild(clip);

      const hue = shape.getAttribute('data-hue');

      // rect pattern (static)
      const pat = document.createElementNS(NS,'rect');
      pat.setAttribute('x', x); pat.setAttribute('y', y);
      pat.setAttribute('width', w); pat.setAttribute('height', h);
      pat.setAttribute('clip-path', 'url(#'+clipId+')');
      if(/^pat/i.test(key)){
        pat.setAttribute('fill', 'url(#'+key+')');
        pat.setAttribute('opacity', '1');
      }else if(key==='gray20'){
        pat.setAttribute('fill', '#808080'); pat.setAttribute('opacity','0.20');
      }else if(key==='gray30'){
        pat.setAttribute('fill', '#808080'); pat.setAttribute('opacity','0.30');
      }else{
        pat.setAttribute('fill', '#808080'); pat.setAttribute('opacity','0.25');
      }
      pat.setAttribute('data-type','static');
      pat.setAttribute('data-nodraw','1');
      if(hue!=null) pat.setAttribute('data-hue', hue);

      // rect che (mask) - biến mất đúng data-hue
      const cover = document.createElementNS(NS,'rect');
      cover.setAttribute('x', x); cover.setAttribute('y', y);
      cover.setAttribute('width', w); cover.setAttribute('height', h);
      cover.setAttribute('clip-path', 'url(#'+clipId+')');
      cover.setAttribute('fill', '#ffffff');
      cover.setAttribute('opacity', '1');
      cover.setAttribute('data-type','mask');
      if(hue!=null) cover.setAttribute('data-hue', hue);

      // Thứ tự vẽ: pat -> cover -> shape
      shape.parentNode.insertBefore(pat, shape);
      shape.parentNode.insertBefore(cover, shape);

      // giữ shape là viền
      try{ shape.setAttribute('fill','none'); }catch(_){}

      shape.__hasFillOverlay = true;
    });
  }

  window.__applyDataFill = applyDataFill;
})();
</script>


<script>
/* === Nebo PATCH: SVG_BANK presets + placeholders (static, data-hue friendly) ===
   Usage:
   1) Declare presets (bank-only) in JS:
      window.SVG_SPECS = [
        { id: 1001, type:"param", xmin:-4,xmax:4,ymin:-4,ymax:4, gridStep:1,
          xExpr:"3*cos(t)", yExpr:"2*sin(t)", tmin:0, tmax:"2*pi", step:0.03, close:true },
        { id: 1002, type:"surface", xmin:-3,xmax:3,ymin:-3,ymax:3, gridStep:1,
          xExpr:"2*cos(u)*cos(v)", yExpr:"2*sin(u)*cos(v)", umin:0, umax:"2*pi", du:0.55,
          vmin:-1.3, vmax:1.3, dv:0.45, ptsStep:0.06 }
      ];

   2) Place in your SVG anywhere:
      <g data-type="static" data-hue="7" data-svg="1001"></g>
      or <g data-type="static" data-hue="9"><span data-svg="1002"></span></g> (HTML zones)

   Behavior:
   - Bank specs are compiled once into window.SVG_BANK[id] (string SVG).
   - Placeholders with [data-svg] are replaced with the SVG markup.
   - Because wrapper keeps your data-hue / data-type, it behaves like "pattern static" (no extra animation).
*/
(function(){
  const NS = "http://www.w3.org/2000/svg";

  window.SVG_BANK = window.SVG_BANK || {};

  function buildToBank(spec){
    const t = String(spec.type||"").toLowerCase();
    if(!spec.id || !isFinite(+spec.id)) throw new Error("SVG spec thiếu id (số).");
    const id = parseInt(spec.id,10);

    const common = Object.assign({}, spec);

    let svg = "";
    if(t === "param"){
      if(typeof window.makeParamCurveSVG !== "function") throw new Error("makeParamCurveSVG chưa có.");
      svg = window.makeParamCurveSVG(common);
    }else if(t === "surface"){
      if(typeof window.makeSurfaceGridSVG !== "function") throw new Error("makeSurfaceGridSVG chưa có.");
      svg = window.makeSurfaceGridSVG(common);
    }else{
      throw new Error('type phải là "param" / "surface".');
    }

    window.SVG_BANK[id] = svg;
    return id;
  }

  // Public: compile all window.SVG_SPECS into SVG_BANK
  window.compileSVGBank = function(){
    try{
      const specs = window.SVG_SPECS || [];
      if(!Array.isArray(specs)) return;
      specs.forEach(s=>{
        try{ buildToBank(s); }catch(e){ console.warn("SVG spec lỗi:", s, e); }
      });
    }catch(_){}
  };

  function parseSVGString(svgMarkup){
    const tmp = document.createElement("div");
    tmp.innerHTML = String(svgMarkup || "").trim();
    const svg = tmp.querySelector("svg");
    return svg || null;
  }

  function adoptInto(targetEl, bankSvg){
    if(!targetEl || !bankSvg) return false;

    // If target is inside an <svg>, we prefer to inject as <g> children (not nested <svg> unless user wants).
    const ownerSVG = targetEl.closest && targetEl.closest("svg");
    const parsed = parseSVGString(bankSvg);
    if(!parsed) return false;

    // Mark placeholder with bank type (param/surface) so timeline can special-handle surfaces.
    try{
      const bt = (parsed.getAttribute('data-bank-type')||'').trim();
      if(bt) targetEl.setAttribute('data-bank-type', bt);
    }catch(_){ }

    // Build a group to hold content (keeps target's data-hue on wrapper)
    const g = document.createElementNS(NS, "g");
    g.setAttribute("class", "bankSvgGroup");

    // Copy children from parsed SVG into group
    const children = Array.from(parsed.childNodes);
    children.forEach(ch=>{
      // skip empty text nodes
      if(ch.nodeType === 3 && !ch.textContent.trim()) return;
      g.appendChild(ch.cloneNode(true));
    });

    // If target itself is SVG element (<g>, <path> etc.)
    if(targetEl.namespaceURI === NS){
      // Replace target's content if it's a container; otherwise replace the node
      const tag = (targetEl.tagName||"").toLowerCase();
      const canHaveChildren = ["g","svg","foreignobject"].includes(tag);
      if(canHaveChildren){
        targetEl.innerHTML = "";
        targetEl.appendChild(g);

        // Propagate data-hue/data-type from placeholder to injected bank group
        try{
          const phHue = targetEl.getAttribute('data-hue');
          const phType = targetEl.getAttribute('data-type');
          if(phHue!=null && String(phHue).trim()!==''){
            try{ g.setAttribute('data-hue', String(phHue));
            // Inherit placeholder hue to any injected mask rect missing data-hue
            try{
              const masks = g.querySelectorAll && g.querySelectorAll('rect[data-type]');
              if(masks && masks.length){
                masks.forEach(rr=>{
                  const tt = String(rr.getAttribute('data-type')||'').toLowerCase().split(/\s+/).filter(Boolean);
                  if(tt.includes('mask')){
                    const rh = rr.getAttribute('data-hue');
                    if(rh==null || String(rh).trim()===''){
                      rr.setAttribute('data-hue', String(phHue));
                    }
                  }
                });
              }
            }catch(_){ } }catch(_){ }
            if(phType!=null && String(phType).trim()!==''){
              try{ g.setAttribute('data-type', String(phType)); }catch(_){ }
            }
            // Also tag descendants if they do not already have data-hue
            try{
              const desc = g.querySelectorAll('*');
              desc.forEach(function(d){
                try{
                  if(d.getAttribute('data-hue')==null){ d.setAttribute('data-hue', String(phHue)); }
                  if(phType!=null && String(phType).trim()!=='' && d.getAttribute('data-type')==null){
                    d.setAttribute('data-type', String(phType));
                  }
                }catch(_){ }
              });
            }catch(_){ }
          }
        }catch(_){ }

        // AUTO surface cover (wipe reveal) - create cover rect after surface injection
        try{
          const bt2 = String(targetEl.getAttribute('data-bank-type')||'').trim().toLowerCase();
          const hasHue2 = (targetEl.getAttribute('data-hue')!=null && String(targetEl.getAttribute('data-hue')).trim()!=='');
          const want2 = (bt2==='surface') && (String(targetEl.getAttribute('data-reveal')||'off').toLowerCase()==='on');
          if(want2 && hasHue2){
            // Defer bbox until next frame (children must be in DOM)
            requestAnimationFrame(()=>{
              try{
                if(targetEl.__autoSurfaceCover) return;
                const inner = targetEl.querySelector(':scope > g.bankSvgGroup') || targetEl.querySelector('g.bankSvgGroup');
                if(!inner) return;
                const bb = inner.getBBox();
                if(!(bb && bb.width>0 && bb.height>0)) return;
                const r = document.createElementNS(NS,'rect');
                r.setAttribute('x', bb.x);
                r.setAttribute('y', bb.y);
                r.setAttribute('width', bb.width);
                r.setAttribute('height', bb.height);
                r.setAttribute('stroke','none');
                r.setAttribute('pointer-events','none');
                r.setAttribute('data-auto','surface-cover');

                // cover fill: prefer data-cover-fill; else try CSS var --paper; else white
                const fillAttr = targetEl.getAttribute('data-cover-fill');
                if(fillAttr){
                  r.setAttribute('fill', fillAttr);
                }else{
                  r.setAttribute('fill', '#fff');
                  try{ r.setAttribute('style', 'fill: var(--paper, #fff);'); }catch(_){ }
                }
                try{ r.style.transformBox='fill-box'; }catch(_){ }
                try{ r.style.transformOrigin='50% 100%'; }catch(_){ }

                targetEl.appendChild(r);
                targetEl.__autoSurfaceCover = r;
              }catch(_){ }
            });
          }
        }catch(_){ }
      }else{
        targetEl.replaceWith(g);
      }
      return true;
    }

    // HTML placeholder: insert a responsive <svg> wrapper
    const wrap = document.createElement("div");
    wrap.className = "bankSvgWrap";
    wrap.innerHTML = bankSvg;
    targetEl.replaceWith(wrap);
    return true;
  }

  // Public: replace placeholders that have data-svg="id"
  window.applySVGBank = function(root){
    const r = root || document;
    const nodes = r.querySelectorAll("[data-svg]");
    nodes.forEach(node=>{
      const id = parseInt(node.getAttribute("data-svg"),10);
      if(!isFinite(id)) return;
      const svg = window.SVG_BANK && window.SVG_BANK[id];
      if(!svg) return;
      // prevent double render
      if(node.getAttribute("data-svgbank-done")==="1") return;
      const ok = adoptInto(node, svg);
      if(ok){
        try{ node.setAttribute("data-svgbank-done","1"); }catch(_){}
      }
    });
  };

  // Auto run (bank compile + apply)
  function boot(){
    try{ window.compileSVGBank(); }catch(_){}
    try{ window.applySVGBank(document); }catch(_){}
  }

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", boot, { once:true });
  }else{
    boot();
  }
})();
</script>

<style>
/* Make bank SVG wrappers responsive in HTML areas */
.bankSvgWrap svg{ width:100% !important; height:auto !important; display:block; }
.bankSvgGroup path, .bankSvgGroup line, .bankSvgGroup polyline, .bankSvgGroup polygon, .bankSvgGroup circle, .bankSvgGroup ellipse, .bankSvgGroup rect{
  vector-effect: non-scaling-stroke;
}
</style>


<script>
/* === PATCH: Allow declaring SVG_SPECS inside the SVG file itself ===
   Put anywhere inside your inline <svg> (recommended near top):

   <script type="application/svgjson" id="bankSpecs">
   [
     { "id":1001, "type":"param", "xExpr":"3*cos(t)", "yExpr":"2*sin(t)", "tmin":0, "tmax":"2*pi", "close":true },
     { "id":1002, "type":"surface", "xExpr":"2*cos(u)*cos(v)", "yExpr":"2*sin(u)*cos(v)", "umin":0, "umax":"2*pi", "vmin":-1.3, "vmax":1.3 }
   ]
   <\/script>

   Or a single object { ... }.

   The HTML stays "script runner"; the SVG carries the math specs.
*/
(function(){
  function collectEmbeddedSpecs(root){
    const r = root || document;
    const out = [];

    // 1) <script type="application/svgjson"> ... <\/script>
    const scripts = r.querySelectorAll('script[type="application/svgjson"]');
    scripts.forEach(sc=>{
      const txt = (sc.textContent||"").trim();
      if(!txt) return;
      try{
        const j = JSON.parse(txt);
        if(Array.isArray(j)) out.push(...j);
        else if(j && typeof j === "object") out.push(j);
      }catch(e){
        console.warn("svgjson parse error:", e);
      }
    });

    // 2) <metadata type="application/svgjson"> ... </metadata>
    const metas = r.querySelectorAll('metadata[type="application/svgjson"], metadata[data-type="application/svgjson"]');
    metas.forEach(md=>{
      const txt = (md.textContent||"").trim();
      if(!txt) return;
      try{
        const j = JSON.parse(txt);
        if(Array.isArray(j)) out.push(...j);
        else if(j && typeof j === "object") out.push(j);
      }catch(e){
        console.warn("metadata svgjson parse error:", e);
      }
    });

    // 3) Per-node specs: <g data-svg-spec='{"id":..., ...}'>
    const nodes = r.querySelectorAll('[data-svg-spec]');
    nodes.forEach(n=>{
      const txt = (n.getAttribute('data-svg-spec')||"").trim();
      if(!txt) return;
      try{
        const j = JSON.parse(txt);
        if(j && typeof j === "object") out.push(j);
      }catch(e){
        console.warn("data-svg-spec parse error:", e);
      }
    });

    return out;
  }

  // Wrap/extend existing compileSVGBank
  const prevCompile = window.compileSVGBank;
  window.compileSVGBank = function(){
    try{
      // 1) compile existing window.SVG_SPECS
      try{ if(typeof prevCompile === "function") prevCompile(); }catch(_){}

      // 2) compile embedded specs from the SVG/document
      const embedded = collectEmbeddedSpecs(document);
      if(Array.isArray(embedded) && embedded.length){
        window.SVG_SPECS = (Array.isArray(window.SVG_SPECS) ? window.SVG_SPECS : []);
        // merge by id (embedded overrides)
        const byId = new Map();
        window.SVG_SPECS.forEach(s=>{ try{ if(s && s.id!=null) byId.set(String(s.id), s); }catch(_){ } });
        embedded.forEach(s=>{ try{ if(s && s.id!=null) byId.set(String(s.id), s); }catch(_){ } });
        window.SVG_SPECS = Array.from(byId.values());

        // build to bank immediately (reuse buildToBank if exists in closure? not accessible)
        // So we call the "old" compile again by temporarily setting SVG_SPECS.
        try{
          if(typeof prevCompile === "function"){
            // prevCompile uses window.SVG_SPECS; call it again to include new specs
            prevCompile();
          }
        }catch(_){}
      }
    }catch(_){}
  };

  // Re-run at DOMContentLoaded (in case the original boot already happened)
  if(document.readyState !== "loading"){
    try{ window.compileSVGBank(); }catch(_){}
    try{ window.applySVGBank(document); }catch(_){}
  }else{
    document.addEventListener("DOMContentLoaded", function(){
      try{ window.compileSVGBank(); }catch(_){}
      try{ window.applySVGBank(document); }catch(_){}
    }, { once:true });
  }
})();
</script>


<script>
/* === PATCH: compileSVGBank retry until param/surface libs exist === */
(function(){
  const MAX_TRIES = 80;   // ~80 frames ~ 1-2s depending
  const RETRY_MS = 50;

  function hasLibs(){
    return (typeof window.makeParamCurveSVG === "function")
        && (typeof window.makeSurfaceGridSVG === "function");
  }

  const prev = window.compileSVGBank;
  if(typeof prev !== "function") return;

  let tries = 0;
  window.compileSVGBank = function(){
    // If libs missing, retry a bit later (keeps old effects intact)
    if(!hasLibs()){
      tries++;
      if(tries < MAX_TRIES){
        setTimeout(()=>{ try{ window.compileSVGBank(); }catch(_){ } }, RETRY_MS);
      }else{
        console.warn("compileSVGBank: libs still missing after retries.");
      }
      return;
    }
    tries = 0;
    return prev();
  };
})();
</script>

<script>
(function(){
  const c = document.getElementById('svgContainer');
  if(!c) return;

  // nếu true: RESUME không ép cuộn theo pending nữa
  window.__userScrollLock = false;

  // phân biệt scroll do code vs scroll do user
  let prog = false;
  const _scrollTo = c.scrollTo.bind(c);

  // wrap scrollTo để đánh dấu "đang scroll theo kịch bản"
  c.scrollTo = function(opts){
    prog = true;
    try { return _scrollTo(opts); }
    finally { setTimeout(()=>{ prog = false; }, 350); }
  };

  // user tương tác => bật lock
  const lock = ()=>{ window.__userScrollLock = true; };

  c.addEventListener('wheel', lock, {passive:true});
  c.addEventListener('touchstart', lock, {passive:true});
  c.addEventListener('pointerdown', lock, {passive:true});
  c.addEventListener('scroll', ()=>{
    if(!prog) window.__userScrollLock = true;
  }, {passive:true});
})();
</script>

<script>
(function(){
  // __SCROLL_VIEN__ (detect outline on #invertToggle, not on svgContainer)
  const c = document.getElementById('svgContainer');
  const page = document.scrollingElement || document.documentElement;
  const mainBtn = ()=>document.getElementById('invertToggle');
  if(!c) return;

  // expose helpers (optional)
  window.__psSetScrollFree = function(on){
    const free = !!on;
    c.classList.toggle('ps-free', free);
    c.classList.toggle('ps-lock', !free);
    if(page) page.style.overflow = free ? '' : 'hidden';
  };

  function hasScrollRange(){
    try{
      const rx = (c.scrollWidth||0) - (c.clientWidth||0);
      const ry = (c.scrollHeight||0) - (c.clientHeight||0);
      return (rx > 2) || (ry > 2);
    }catch(_){ return false; }
  }

  let t = null;
  let lastMode = 'unknown'; // 'manual'|'system'|'play'

  function readOutlineMode(){
    try{
      const b = mainBtn();
      if(!b) return 'play';
      const cs = getComputedStyle(b);
      const style = (cs.outlineStyle || 'none').toLowerCase();
      const w = parseFloat(cs.outlineWidth || '0') || 0;
      if(style === 'none' || w <= 0.5) return 'play';
      if(style === 'dashed') return 'system'; // wait by script
      return 'manual'; // solid (or others) => user manual pause
    }catch(_){
      return 'play';
    }
  }

  function scheduleApply(mode){
    if(t){ try{ clearTimeout(t); }catch(_){ } t=null; }
    t = setTimeout(function(){
      // Only auto-free when manual pause AND there is something to scroll
      if(mode === 'manual' && hasScrollRange()){
        window.__psSetScrollFree(true);
      }else{
        window.__psSetScrollFree(false);
      }
    }, 500); // 1s as requested
  }

  function tick(){
    const mode = readOutlineMode();
    if(mode !== lastMode){
      lastMode = mode;
      scheduleApply(mode);
    }
  }

  // default lock
  window.__psSetScrollFree(false);

  // observe class/style changes on the main button and body
  try{
    const mo = new MutationObserver(()=>tick());
    mo.observe(document.body, {subtree:true, attributes:true, childList:true, attributeFilter:['style','class']});
  }catch(_){}

  // polling fallback (safe)
  setInterval(tick, 200);

})();
</script>

<script>
(function(){
  // __AUTO_PAUSE_ON_MODECHANGE_V1__
  function getOutlineMode(){
    try{
      const b = document.getElementById('invertToggle');
      if(!b) return 'play';
      const cs = getComputedStyle(b);
      const style = (cs.outlineStyle || 'none').toLowerCase();
      const w = parseFloat(cs.outlineWidth || '0') || 0;
      if(style === 'none' || w <= 0.5) return 'play';
      if(style === 'dashed') return 'system';
      return 'manual';
    }catch(_ ){ return 'play'; }
  }

  window.__autoPauseLayoutOnce = function(){
    try{
      const mode = getOutlineMode();
      if(mode !== 'play') return;

      const wasPlaying = !!(window.svgIsPlaying || window.ttsIsPlaying || (window.tl && window.tl.isActive && window.tl.isActive()));
      if(!wasPlaying) return;

      if(window.__layoutPauseTimer) {
        clearTimeout(window.__layoutPauseTimer);
        window.__layoutPauseTimer = null;
      }

      try{ window.tl && window.tl.pause && window.tl.pause(); }catch(_ ){}
      try{
        const ss = window.speechSynthesis;
        if(ss && ss.speaking && ss.pause) ss.pause();
      }catch(_ ){}

      try{ window.svgIsPlaying = false; window.ttsIsPlaying = false; }catch(_ ){}
      try{ typeof window.showPauseCue === 'function' && window.showPauseCue(); }catch(_ ){}

      window.__layoutPauseTimer = setTimeout(function(){
        window.__layoutPauseTimer = null;
        try{ if(getOutlineMode() !== 'play') return; }catch(_ ){}

        try{ window.tl && window.tl.resume && window.tl.resume(); }catch(_ ){}
        try{
          const ss = window.speechSynthesis;
          if(ss && ss.paused && ss.resume) ss.resume();
          if(!(ss && ss.speaking) && typeof window.speakPart === 'function') {
            try{ window.ttsIsPlaying = true; window.speakPart(); }catch(_ ){}
          }
        }catch(_ ){}

        try{ window.svgIsPlaying = true; }catch(_ ){}
        try{ typeof window.showPlayCue === 'function' && window.showPlayCue(); }catch(_ ){}
        try{ window.__psSetScrollFree && window.__psSetScrollFree(false); }catch(_ ){}
      }, 500);
    }catch(_ ){}
  };
})();
</script>
</body>
</html>

<!-- fromBand override appended -->
<script>
(function(){
  // Helpers
  function ensureSceneGroups(svg){
    if(!svg) return;
    if(svg.querySelector('#scene')) return;
    const scene = document.createElementNS('http://www.w3.org/2000/svg','g'); scene.id='scene';
    const base  = document.createElementNS('http://www.w3.org/2000/svg','g'); base.id='base';
    const paints= document.createElementNS('http://www.w3.org/2000/svg','g'); paints.id='paints';
    const moves = [];
    svg.childNodes.forEach(n=>{ if(n.nodeType===1 && n.tagName!=='defs') moves.push(n); });
    moves.forEach(n=>{ base.appendChild(n); });
    scene.appendChild(base); scene.appendChild(paints); svg.appendChild(scene);
  }
  function hasCrossBand(svg, splitIsHorizontal){
    const els = svg.querySelectorAll('[data-band]');
    let hasPlus=false, hasMinus=false;
    els.forEach(el=>{
      const s = (el.getAttribute('data-band')||'');
      if (s.includes('+')) hasPlus = true;
      if (s.includes('-')) hasMinus = true;
    });
    return hasPlus && hasMinus;
  }
  function applyHighlightMasks(svg){
    if(!svg) return;
    const scene = svg.querySelector('#scene') || svg;
    const base  = svg.querySelector('#base')  || scene;
    const paints= svg.querySelector('#paints')|| null;
    const vbStr = (svg.getAttribute('viewBox')||'').trim();
    const vb = vbStr ? vbStr.split(/[,\s]+/).map(Number) : [0,0,1000,1000];
    const [vx,vy,vw,vh] = (vb.length===4? vb : [0,0,1000,1000]);

    let defs = svg.querySelector('defs'); if(!defs){ defs=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.insertBefore(defs, svg.firstChild); }
    const old = svg.querySelector('#mask_scene'); if(old) old.remove();

    function isEraser(n){
      if(!n) return false;
      const c=(n.getAttribute('class')||'').toLowerCase();
      if(/\beras(er)?\b/.test(c)) return true;
      if((n.getAttribute('data-erase')||'').toLowerCase()==='1') return true;
      if((n.getAttribute('data-mode')||'').toLowerCase()==='erase') return true;
      return false;
    }
    const allHighlights = (paints? paints: scene).querySelectorAll('[data-type="highlight"]');
    const erasers = Array.from(allHighlights).filter(isEraser);
    if(!erasers.length){ base.removeAttribute('mask'); return; }

    const mask = document.createElementNS('http://www.w3.org/2000/svg','mask');
    mask.setAttribute('id','mask_scene');
    mask.setAttribute('maskUnits','userSpaceOnUse');
    mask.setAttribute('x',vx); mask.setAttribute('y',vy);
    mask.setAttribute('width',vw); mask.setAttribute('height',vh);

    const white = document.createElementNS('http://www.w3.org/2000/svg','rect');
    white.setAttribute('x',vx); white.setAttribute('y',vy);
    white.setAttribute('width',vw); white.setAttribute('height',vh);
    white.setAttribute('fill','#fff');
    mask.appendChild(white);

    erasers.forEach(h=>{
      const clone = h.cloneNode(true);
      clone.removeAttribute('filter'); clone.removeAttribute('mask');
      clone.style.mixBlendMode='normal'; clone.setAttribute('opacity','1');
      if (clone.tagName && clone.tagName.toLowerCase()==='path'){
        const d0 = clone.getAttribute('d')||'';
        if (/[zZ]\s*$/.test(d0)) clone.setAttribute('d', d0.replace(/[zZ]\s*$/,'').trim());
      }
      const hasFill = (clone.getAttribute('fill')||'').toLowerCase()!=='none' && (clone.getAttribute('fill')||'')!=='';
      if (hasFill){ clone.setAttribute('fill','#000'); clone.setAttribute('stroke','none'); }
      else { clone.setAttribute('stroke','#000'); clone.setAttribute('fill','none'); clone.setAttribute('stroke-width', clone.getAttribute('stroke-width') || '2'); clone.setAttribute('stroke-linecap','round'); clone.setAttribute('stroke-linejoin','round'); }
      mask.appendChild(clone);
    });

    defs.appendChild(mask);
    erasers.forEach(h=>{ h.style.pointerEvents='none'; });  // giữ nguyên opacity để eraser vẫn hiện trong mode mask
    base.setAttribute('mask','url(#mask_scene)');
    if(paints){ try{ (svg.querySelector('#scene')||svg).appendChild(paints); }catch(_){} }
  }

  // Save original if exists
  if (!window.__applyLayoutOrig && typeof window.applyLayout === 'function'){
    window.__applyLayoutOrig = window.applyLayout;
  }

  // Replace with fromBand version (preserve UI)
  window.applyLayout = function(){
    const svg = (window.svgEl && window.svgEl()) || document.querySelector('svg');
    if(!svg) return;
    ensureSceneGroups(svg);

    Array.from(svg.querySelectorAll('#frame1,#frame2,#clip1,#clip2')).forEach(n=>n.remove());

    let vbStr = (svg.getAttribute('viewBox')||'').trim();
    if(!vbStr){
      try{
        const b = (svg.querySelector('#scene')||svg).getBBox();
        vbStr = [b.x,b.y,Math.max(1,b.width),Math.max(1,b.height)].join(' ');
        svg.setAttribute('viewBox', vbStr);
      }catch(e){
        vbStr = "0 0 1000 1000";
        svg.setAttribute('viewBox', vbStr);
      }
    }
    const [x,y,w,h] = vbStr.split(/[,\s]+/).map(Number);
    const isScreenPortrait = window.innerHeight > window.innerWidth;
    const isSvgPortrait    = h > w;
    const params = new URLSearchParams(location.search);
    const hasNo = params.has('no') || (params.get('no')||'').toLowerCase()==='true' || params.get('no')==='1' || params.get('no')==='';
    const isTraiChieu = (!isScreenPortrait && isSvgPortrait) || (isScreenPortrait && !isSvgPortrait);
    const cross = hasCrossBand(svg, isSvgPortrait);

    const twoFrame = (!hasNo && isTraiChieu && cross);
    svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);

    
    // --- Special rule: when TRÁI CHIỀU and HAS NO -> single-axis scroll by screen orientation
    // screen ngang  => trượt dọc (overflowY),  screen dọc => trượt ngang (overflowX).
    if (hasNo && isTraiChieu){
      const container = document.getElementById('svgContainer') || document.querySelector('#svgContainer') || document.body;
      // keep one frame, keep original viewBox (already set)
      svg.style.width = isScreenPortrait ? 'auto' : '100%';
      svg.style.height = isScreenPortrait ? '100%' : 'auto';
      if (!isScreenPortrait){
        // screen landscape -> vertical scroll
        container.style.overflowY='auto'; container.style.overflowX='hidden';
      } else {
        // screen portrait -> horizontal scroll
        container.style.overflowX='auto'; container.style.overflowY='hidden';
      }
      
  /* __CENTER_BLOCK__ */
  (function(){
    const container = document.getElementById('svgContainer') || document.querySelector('#svgContainer') || document.body;
    if (container){
      container.style.display = 'flex';
      container.style.alignItems = 'center';
      container.style.justifyContent = 'center';
    }
    if (svg){
      svg.style.margin = 'auto';
      svg.style.maxWidth = '100%';
      svg.style.maxHeight = '100%';
    }
  })();
try{ applyHighlightMasks(svg); }catch(e){}
      return; // early exit
    }
if(twoFrame){
      let defs = svg.querySelector('defs'); if(!defs){ defs=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.insertBefore(defs, svg.firstChild); }
      const cp1 = document.createElementNS('http://www.w3.org/2000/svg','clipPath'); cp1.id='clip1';
      const cp2 = document.createElementNS('http://www.w3.org/2000/svg','clipPath'); cp2.id='clip2';
      defs.appendChild(cp1); defs.appendChild(cp2);

      if(isSvgPortrait){
        const rtop = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rtop.setAttribute('x',x); rtop.setAttribute('y',y); rtop.setAttribute('width',w); rtop.setAttribute('height',h/2);
        const rbot = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rbot.setAttribute('x',x); rbot.setAttribute('y',y+h/2); rbot.setAttribute('width',w); rbot.setAttribute('height',h/2);
        cp1.appendChild(rtop); cp2.appendChild(rbot);

        const u1 = document.createElementNS('http://www.w3.org/2000/svg','use'); u1.id='frame1';
        u1.setAttributeNS('http://www.w3.org/1999/xlink','href','#scene'); u1.setAttribute('clip-path','url(#clip1)'); svg.appendChild(u1);

        const u2 = document.createElementNS('http://www.w3.org/2000/svg','use'); u2.id='frame2';
        u2.setAttributeNS('http://www.w3.org/1999/xlink','href','#scene'); u2.setAttribute('clip-path','url(#clip2)');
        u2.setAttribute('transform', `translate(0, ${h/2})`); svg.appendChild(u2);

        svg.setAttribute('viewBox', `${x} ${y} ${w} ${h*2}`);
      } else {
        const rleft = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rleft.setAttribute('x',x); rleft.setAttribute('y',y); rleft.setAttribute('width',w/2); rleft.setAttribute('height',h);
        const rright = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rright.setAttribute('x',x+w/2); rright.setAttribute('y',y); rright.setAttribute('width',w/2); rright.setAttribute('height',h);
        cp1.appendChild(rleft); cp2.appendChild(rright);

        const u1 = document.createElementNS('http://www.w3.org/2000/svg','use'); u1.id='frame1';
        u1.setAttributeNS('http://www.w3.org/1999/xlink','href','#scene'); u1.setAttribute('clip-path','url(#clip1)'); svg.appendChild(u1);

        const u2 = document.createElementNS('http://www.w3.org/2000/svg','use'); u2.id='frame2';
        u2.setAttributeNS('http://www.w3.org/1999/xlink','href','#scene'); u2.setAttribute('clip-path','url(#clip2)');
        u2.setAttribute('transform', `translate(${w/2}, 0)`); svg.appendChild(u2);

        svg.setAttribute('viewBox', `${x} ${y} ${w*2} ${h}`);
      }
    }

    const container = document.getElementById('svgContainer') || document.querySelector('#svgContainer') || document.body;
    const isSvgPortraitNow = (svg.viewBox && svg.viewBox.baseVal) ? (svg.viewBox.baseVal.height > svg.viewBox.baseVal.width) : isSvgPortrait;
    if (isSvgPortraitNow){ svg.style.width='100%'; svg.style.height='auto'; container.style.overflowY='auto'; container.style.overflowX='hidden'; }
    else { svg.style.width='auto'; svg.style.height='100%'; container.style.overflowX='auto'; container.style.overflowY='hidden'; }

    try{ applyHighlightMasks(svg); }catch(e){}
  };

  // Trigger relayout if app already loaded
  try{ if (typeof window.onAfterSvgLoaded === 'function') { window.onAfterSvgLoaded(); } }catch(_){}
})();
</script>

<script>
(function(){
  function fixOrientation(){
    setTimeout(function(){
      try{
        if (window.applyOrientation) {
          window.applyOrientation();
        } else if (window.updateLayout) {
          window.updateLayout();
        }
      }catch(e){}
    }, 180);
  }
  window.addEventListener('orientationchange', fixOrientation);
})();

</script>
<script>
let lastTapTime = 0;
const DOUBLE_TAP_DELAY = 300;

// ---------- TOUCH (DOUBLE TAP) ----------
document.addEventListener("touchend", (e) => {
  const now = Date.now();
  if (now - lastTapTime < DOUBLE_TAP_DELAY) {
    toggleFullscreen();
    lastTapTime = 0;
  } else {
    lastTapTime = now;
  }
}, { passive: true });

// ---------- MOUSE (DOUBLE CLICK) ----------
document.addEventListener("dblclick", (e) => {
  toggleFullscreen();
});

// ---------- KEYBOARD (GIỮ CÁI CŨ RẤT TỐT) ----------
document.addEventListener("keydown", (e) => {
  if (e.shiftKey && e.code === "Space") {
    e.preventDefault();
    toggleFullscreen();
  }
});

// ---------- FULLSCREEN CORE ----------
function toggleFullscreen() {
  if (document.fullscreenElement) {
    exitFullscreen();
  } else {
    enterFullscreen();
  }
}

function enterFullscreen() {
  const elem = document.documentElement;
  if (elem.requestFullscreen) elem.requestFullscreen();
  else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
  else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
}

function exitFullscreen() {
  if (document.exitFullscreen) document.exitFullscreen();
  else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
  else if (document.msExitFullscreen) document.msExitFullscreen();
}
</script>

<script>
/* ==================== VIEWPORT / ORIENTATION RESIZE FIX ==================== */

(function(){
  let resizeTimer = null;

  function applyViewportSize(){
    try{
      const c = document.getElementById('svgContainer');
      if(!c) return;

      /* 1) Fix viewport height (mobile browser bug) */
      let vh = window.innerHeight;
      let vw = window.innerWidth;

      // ưu tiên visualViewport nếu có (Chrome / Android rất chuẩn)
      if(window.visualViewport){
        vh = Math.round(window.visualViewport.height);
        vw = Math.round(window.visualViewport.width);
      }

      c.style.width  = vw + 'px';
      c.style.height = vh + 'px';

      /* 2) Force SVG relayout */
      const svg = c.querySelector('svg');
      if(svg){
        svg.style.width  = '100vw';
        svg.style.height = '100vh';

        // ép browser recompute bounding box
        try{
          svg.getBoundingClientRect();
        }catch(_){}
      }
    }catch(_){}
  }

  function scheduleResize(){
    if(resizeTimer) clearTimeout(resizeTimer);

    // delay 2 nhịp → chờ browser cập nhật orientation/fullscreen xong
    resizeTimer = setTimeout(()=>{
      applyViewportSize();
    }, 120);
  }

  /* ===== LISTENERS ===== */
  window.addEventListener('resize', scheduleResize, {passive:true});
  window.addEventListener('orientationchange', scheduleResize);
  document.addEventListener('fullscreenchange', scheduleResize);
  document.addEventListener('webkitfullscreenchange', scheduleResize);

  // Android Chrome / Edge
  if(window.visualViewport){
    window.visualViewport.addEventListener('resize', scheduleResize);
    window.visualViewport.addEventListener('scroll', scheduleResize);
  }

  // iOS Safari fallback
  window.addEventListener('pageshow', scheduleResize);

  // initial
  document.addEventListener('DOMContentLoaded', ()=>{
    setTimeout(applyViewportSize, 50);
  });

})();
</script>



<!-- === PARAM UV LIB (curve t + surface grid u,v) === -->
<script>
(function(){
  const NS = "http://www.w3.org/2000/svg";
  const M = Math;

  // Safe math environment: allow sin(t), pi, ...
  const env = {
    pi: M.PI, e: M.E,
    sin:M.sin, cos:M.cos, tan:M.tan,
    asin:M.asin, acos:M.acos, atan:M.atan, atan2:M.atan2,
    sqrt:M.sqrt, abs:M.abs, pow:M.pow,
    log:M.log, exp:M.exp,
    min:M.min, max:M.max,
    floor:M.floor, ceil:M.ceil, round:M.round
  };

  function safeExpr(expr){
    const s = String(expr ?? "").trim();
    if(!s) throw new Error("Biểu thức rỗng.");
    // allow: digits, operators, letters, underscores, commas, dots, spaces, parentheses
    if(!/^[0-9+*/^()., a-zA-Z_-]+$/.test(s)){
      throw new Error("Biểu thức có ký tự không hợp lệ.");
    }
    return s.replace(/\\^/g, "**");
  }

  function compileExpr(expr, vars){
    const js = safeExpr(expr);
    const v = (vars || []).filter(Boolean);
    const body = "with(env){ return (" + js + "); }";
    return new Function(...v, "env", body);
  }

  function evalConst(v){
    if (typeof v === "number") return v;
    if (typeof v === "string") {
      const f = compileExpr(v, []);
      return f(env);
    }
    return Number(v);
  }

  function mkFrame({W,H,xmin,xmax,ymin,ymax,gridStep=1}){
    const X = x => (x - xmin) * W / (xmax - xmin);
    const Y = y => (ymax - y) * H / (ymax - ymin);

    let g = "";
    const step = gridStep || 1;

    // grid
    for(let x = Math.ceil(xmin/step)*step; x <= xmax + 1e-9; x += step){
      const px = X(x);
      g += '<line x1="'+px.toFixed(2)+'" y1="0" x2="'+px.toFixed(2)+'" y2="'+H+'" stroke="currentColor" opacity="0.15" stroke-width="1"/>';
    }
    for(let y = Math.ceil(ymin/step)*step; y <= ymax + 1e-9; y += step){
      const py = Y(y);
      g += '<line x1="0" y1="'+py.toFixed(2)+'" x2="'+W+'" y2="'+py.toFixed(2)+'" stroke="currentColor" opacity="0.15" stroke-width="1"/>';
    }

    // axes
    if(xmin < 0 && xmax > 0){
      const px = X(0);
      g += '<line x1="'+px.toFixed(2)+'" y1="0" x2="'+px.toFixed(2)+'" y2="'+H+'" stroke="currentColor" opacity="0.55" stroke-width="1.5"/>';
    }
    if(ymin < 0 && ymax > 0){
      const py = Y(0);
      g += '<line x1="0" y1="'+py.toFixed(2)+'" x2="'+W+'" y2="'+py.toFixed(2)+'" stroke="currentColor" opacity="0.55" stroke-width="1.5"/>';
    }

    return { X, Y, frameMarkup: g };
  }

  function polyPath(points, X, Y){
    let d = "";
    let first = true;
    for(const p of points){
      if(!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) { first = true; continue; }
      const px = X(p.x), py = Y(p.y);
      d += (first ? "M " : "L ") + px.toFixed(2) + " " + py.toFixed(2) + " ";
      first = false;
    }
    return d.trim();
  }

  // ---- 1 parameter curve: returns full <svg> markup ----
  function makeParamCurveSVG(opts){
    opts = opts || {};
    const W = Number(opts.width || 120);
    const H = Number(opts.height || 84);

    const xmin = (opts.xmin ?? -5), xmax = (opts.xmax ?? 5);
    const ymin = (opts.ymin ?? -5), ymax = (opts.ymax ?? 5);
    const gridStep = (opts.gridStep ?? 1);

    const xExpr = (opts.xExpr ?? "cos(t)");
    const yExpr = (opts.yExpr ?? "sin(t)");
    const zExpr = (opts.zExpr ?? null);
    const t0 = evalConst(opts.tmin ?? 0);
    const t1 = evalConst(opts.tmax ?? "2*pi");
    const step = Number(opts.step ?? 0.03);

    const close = !!opts.close;
    const stroke = (opts.stroke ?? "currentColor");
    const strokeWidth = (opts.strokeWidth ?? 2);
    const fill = (opts.fill ?? "none");
    const extraAttrs = (opts.extraAttrs ?? "");

    const fx = compileExpr(xExpr, ["t"]);
    const fy = compileExpr(yExpr, ["t"]);
    const fz = zExpr ? compileExpr(String(zExpr), ["t"]) : null;
    const {X,Y} = mkFrame({W,H,xmin,xmax,ymin,ymax,gridStep});
    const frameMarkup = "";
const pts = [];
    const n = Math.max(10, Math.floor((t1 - t0) / (step || 0.03)));
    for(let i=0;i<=n;i++){
      const t = t0 + (t1 - t0) * (i/n);
      const x = fx(t, env);
      const y = fy(t, env);
      const z = fz ? fz(t, env) : 0;
      const [Xp, Yp] = project3D(x, y, z, opts);
      pts.push({x: Xp, y: Yp});
    }
    let d = polyPath(pts, X, Y);
    if(close && d) d += " Z";

    return '<svg data-bank-type="param" xmlns="'+NS+'" viewBox="0 0 '+W+' '+H+'" width="100%" height="100%">' +
            '<path d="'+d+'" fill="'+fill+'" stroke="'+stroke+'" stroke-width="'+strokeWidth+'" stroke-linecap="round" stroke-linejoin="round" '+extraAttrs+'></path>' +
    '</svg>';
  }

  // ---- 2 parameter surface grid: returns full <svg> markup ----
  function makeSurfaceGridSVG(opts){
    opts = opts || {};
    const W = Number(opts.width || 120);
    const H = Number(opts.height || 84);

    const xmin = (opts.xmin ?? -5), xmax = (opts.xmax ?? 5);
    const ymin = (opts.ymin ?? -5), ymax = (opts.ymax ?? 5);
    const gridStep = (opts.gridStep ?? 1);

    const xExpr = (opts.xExpr ?? "u");
    const yExpr = (opts.yExpr ?? "v");

    const zExpr = (opts.zExpr ?? null);

    const U0 = evalConst(opts.umin ?? -2);
    const U1 = evalConst(opts.umax ?? 2);
    const V0 = evalConst(opts.vmin ?? -2);
    const V1 = evalConst(opts.vmax ?? 2);

    // --- Density controls (synced): prefer nu/nv/segU/segV, but keep backward compatibility with du/dv/ptsStep ---
    // nu,nv: number of divisions for the u/v grid-lines (inclusive endpoints)
    // segU,segV: sampling resolution along each line in u/v direction
    function toIntOr(v, d){
      const n = (v == null) ? NaN : Number(v);
      return (Number.isFinite(n) && Math.floor(n) === n) ? n : d;
    }
    function toPosFiniteOr(v, d){
      const n = (v == null) ? NaN : Number(v);
      return (Number.isFinite(n) && n > 0) ? n : d;
    }

   const nu   = toIntOr(opts.nu,   4);
const nv   = toIntOr(opts.nv,   4);
const segU = toIntOr(opts.segU, 200);
const segV = toIntOr(opts.segV, 200);

    // Normalize ranges (allow user to give umin>umax or vmin>vmax)
    const uMin = Math.min(U0, U1), uMax = Math.max(U0, U1);
    const vMin = Math.min(V0, V1), vMax = Math.max(V0, V1);
    const uRange = Math.max(1e-9, (uMax - uMin));
    const vRange = Math.max(1e-9, (vMax - vMin));

    // Back-compat: if user provided du/dv explicitly, respect it. Otherwise derive from nu/nv.
    // Back-compat: if user provided du/dv explicitly, respect it (including expressions like "pi/2"). Otherwise derive from nu/nv.
    function toPosFiniteExprOr(v, d){
      if(v == null) return d;
      let n = Number(v);
      if(!Number.isFinite(n)){
        try{ n = evalConst(v); }catch(e){ n = NaN; }
      }
      return (Number.isFinite(n) && n > 0) ? n : d;
    }

    const du = (opts.du != null) ? toPosFiniteExprOr(opts.du, 0.4)
              : (nu != null ? (uRange / Math.max(1, nu)) : 0.4);
    const dv = (opts.dv != null) ? toPosFiniteExprOr(opts.dv, 0.4)
              : (nv != null ? (vRange / Math.max(1, nv)) : 0.4);
// Sampling step along each direction: prefer segU/segV; else fall back to ptsStep; else a sensible default
    const ptsStepFallback = toPosFiniteOr(opts.ptsStep, 0.06);
    const ptsStepU = (segU != null) ? (uRange / Math.max(2, segU)) : ptsStepFallback;
    const ptsStepV = (segV != null) ? (vRange / Math.max(2, segV)) : ptsStepFallback;

    const stroke = (opts.stroke ?? "currentColor");
    const strokeWidth = (opts.strokeWidth ?? 1.3);
    const opacity = (opts.opacity ?? 0.95);

    const fx = compileExpr(xExpr, ["u","v"]);
    const fy = compileExpr(yExpr, ["u","v"]);
    const fz = zExpr ? compileExpr(String(zExpr), ["u","v"]) : null;
    const {X,Y} = mkFrame({W,H,xmin,xmax,ymin,ymax,gridStep});
    const frameMarkup = "";
let paths = "";

    const showHidden = (opts.showHidden != null) ? !!opts.showHidden : (opts.hidden != null ? !!opts.hidden : true);
    const hiddenDash = String(opts.hiddenDash ?? opts.dashHidden ?? opts.dash ?? "4 4");

    function pos(u,v){
      const x = fx(u,v, env);
      const y = fy(u,v, env);
      const z = fz ? fz(u,v, env) : 0;
      if(!Number.isFinite(x)||!Number.isFinite(y)||!Number.isFinite(z)) return null;
      return {x:+x,y:+y,z:+z};
    }

    // numerical normal
    const uSpan = Math.max(1e-6, Math.abs(uMax-uMin));
    const vSpan = Math.max(1e-6, Math.abs(vMax-vMin));
    const epsU = Math.max(1e-6, uSpan*1e-4);
    const epsV = Math.max(1e-6, vSpan*1e-4);

    // --- Auto edgePad for stable normals near boundaries (keeps grid lines at exact uMin/uMax) ---
    const edgePadBase = (opts.edgePad != null) ? evalConst(opts.edgePad) : NaN;
    const edgePadU = (opts.edgePadU != null) ? evalConst(opts.edgePadU) : (Number.isFinite(edgePadBase) ? edgePadBase : uRange*0.002);
    const edgePadV = (opts.edgePadV != null) ? evalConst(opts.edgePadV) : (Number.isFinite(edgePadBase) ? edgePadBase : vRange*0.002);
    const uMinN = uMin + Math.max(0, Math.min(uRange*0.49, edgePadU));
    const uMaxN = uMax - Math.max(0, Math.min(uRange*0.49, edgePadU));
    const vMinN = vMin + Math.max(0, Math.min(vRange*0.49, edgePadV));
    const vMaxN = vMax - Math.max(0, Math.min(vRange*0.49, edgePadV));
    function clamp(x,a,b){ return (x<a)?a:((x>b)?b:x); }

    function sub(A,B){ return {x:A.x-B.x,y:A.y-B.y,z:A.z-B.z}; }
    function cross(a,b){ return {x:a.y*b.z-a.z*b.y, y:a.z*b.x-a.x*b.z, z:a.x*b.y-a.y*b.x}; }
    
    function normal(u,v){
      // Compute normal for visibility test using clamped params (avoids missing lines at boundaries)
      const uN = clamp(u, uMinN, uMaxN);
      const vN = clamp(v, vMinN, vMaxN);

      const u0 = Math.max(uMin, uN - epsU), u1 = Math.min(uMax, uN + epsU);
      const v0 = Math.max(vMin, vN - epsV), v1 = Math.min(vMax, vN + epsV);
      if(u1 - u0 < 1e-12 || v1 - v0 < 1e-12) return null;

      const pu1 = pos(u1, vN), pu0 = pos(u0, vN);
      const pv1 = pos(uN, v1), pv0 = pos(uN, v0);
      if(!pu1||!pu0||!pv1||!pv0) return null;
      return cross(sub(pu1, pu0), sub(pv1, pv0));
    }


    // view direction consistent with project3D(x,y,z,s,m)
    const vars = (opts && opts.vars) ? opts.vars : {};
    const mm = Number(vars.m ?? opts.m ?? 0.8);
    const ss = (vars.s == null && opts.s == null) ? 0 : evalConst(vars.s ?? opts.s);

    // project3D does: X = x*cos(s) - y*sin(s)
    //               Y = m*(x*sin(s)+y*cos(s)) + k*z, k = sqrt(1-m^2)
    // Ray direction V satisfies dX=0, dY=0 -> V ∝ (k*sin(s), k*cos(s), -m)
    const k  = Math.sqrt(Math.max(0, 1 - mm*mm));
    const Vx = k*Math.sin(ss);
    const Vy = k*Math.cos(ss);
    const Vz = -mm;

    function projectPt(P){
      const XY = project3D(P.x, P.y, P.z, opts);
      return {x: XY[0], y: XY[1]};
    }

    function addPath(points, dashed){
      const d = polyPath(points, X, Y);
      if(!d) return;
      if(!dashed){
        paths += '<path d="'+d+'" fill="none" stroke="'+stroke+'" stroke-width="'+strokeWidth+'" stroke-linecap="round" stroke-linejoin="round" opacity="'+opacity+'" data-type="static" data-hue="00" data-nosort="1"></path>';
      }else if(showHidden){
        paths += '<path d="'+d+'" fill="none" stroke="'+stroke+'" stroke-width="'+strokeWidth+'" stroke-linecap="butt" stroke-linejoin="round" opacity="'+opacity+'" stroke-dasharray="6 4" stroke-dashoffset="0" data-type="dashstatic" data-hue="00" data-nosort="1"></path>';
      }
    }

    function rangeVals(a,b,step){
      const out=[];
      if(!Number.isFinite(a)||!Number.isFinite(b)||!Number.isFinite(step)||step<=0) return out;
      const dir=(b>=a)?1:-1;
      const st=Math.abs(step)*dir;
      for(let t=a; dir>0?(t<=b+1e-12):(t>=b-1e-12); t+=st){
        out.push(t);
        if(out.length>20000) break;
      }
      if(out.length && Math.abs(out[out.length-1]-b)>1e-9) out.push(b);
      if(!out.length) out.push(a,b);
      return out;
    }

    // finer step for splitting (auto)
    let gridPtsStep = toPosFiniteOr(opts.gridPtsStep, NaN);
    if(!Number.isFinite(gridPtsStep) || gridPtsStep<=0){
      const base = Math.min(du, dv);
      gridPtsStep = (Number.isFinite(base) && base>0) ? Math.max(1e-6, base/3) : 0.06;
    }
    const uFine = rangeVals(uMin, uMax, gridPtsStep);
    const vFine = rangeVals(vMin, vMax, gridPtsStep);

    function splitCurve(paramVals, getUV){
      const vis=[], hid=[];
      let seg=[], segVis=null;
      let prev=null, prevS=null;

      function flush(){
        if(seg.length>=2){
          if(segVis) vis.push(seg.slice());
          else hid.push(seg.slice());
        }
        seg=[];
      }

      for(let i=0;i<paramVals.length;i++){
        const t=paramVals[i];
        const uv=getUV(t);
        const P=pos(uv.u, uv.v);
        const N=normal(uv.u, uv.v);
        if(!P||!N){
          flush(); prev=null; prevS=null; segVis=null;
          continue;
        }
        const sgn = N.x*Vx + N.y*Vy + N.z*Vz;
        const isVis = (sgn > 0) /* flipped to match Nebo view */;
        const Q = projectPt(P);

        if(prev===null){
          segVis=isVis;
          seg.push(Q);
          prev=P; prevS=sgn;
          continue;
        }

        const s0=prevS, s1=sgn;
        const change = (s0===0)?true:(s0*s1<0);

        if(change){
          const tFrac = (s0===s1)?0.5:(s0/(s0-s1));
          const Pb={x: prev.x+(P.x-prev.x)*tFrac,
                    y: prev.y+(P.y-prev.y)*tFrac,
                    z: prev.z+(P.z-prev.z)*tFrac};
          const Qb = projectPt(Pb);
          seg.push(Qb);
          flush();
          segVis=isVis;
          seg.push(Qb);
          seg.push(Q);
        }else{
          if(segVis===null) segVis=isVis;
          if(segVis!==isVis){ flush(); segVis=isVis; }
          seg.push(Q);
        }

        prev=P; prevS=sgn;
      }
      flush();
      return {vis,hid};
    }

    // u fixed
    for(let u=uMin; u<=uMax+1e-9; u+=du){
      const r = splitCurve(vFine, (t)=>({u, v:t}));
      r.vis.forEach(seg=>addPath(seg,false));
      r.hid.forEach(seg=>addPath(seg,true));
    }

    // v fixed
    for(let v=vMin; v<=vMax+1e-9; v+=dv){
      const r = splitCurve(uFine, (t)=>({u:t, v}));
      r.vis.forEach(seg=>addPath(seg,false));
      r.hid.forEach(seg=>addPath(seg,true));
    }
    const maskHue = (opts.maskHue ?? null);
    let maskRect = "";
    if(maskHue != null){
      // rect che: NeboNos/Nebo3df runner will fade mask 1->0 at data-hue
      maskRect = '<rect x="0" y="0" width="'+W+'" height="'+H+'" fill="#fff" opacity="1" pointer-events="none" data-type="mask" data-hue="'+maskHue+'"></rect>';
    }else{
      // If user sets hue on placeholder (<g data-hue ... data-svg=...>), adoptInto() will assign it.
      maskRect = '<rect x="0" y="0" width="'+W+'" height="'+H+'" fill="#fff" opacity="1" pointer-events="none" data-type="mask"></rect>';
    }

    return '<svg data-bank-type="surface" xmlns="'+NS+'" viewBox="0 0 '+W+' '+H+'" width="100%" height="100%">' +
       paths +
       maskRect +
    '</svg>';
  }

  // expose
  
  // === Aliases for minimal runner (no grid): return SVG elements (not full <svg>) ===
  function project3D(x, y, z, spec){
    const vars = (spec && spec.vars) ? spec.vars : {};
    const m = Number(vars.m ?? 1);
    const s = (vars.s == null) ? 0 : evalConst(vars.s);
    const cs = Math.cos(s);
    const sn = Math.sin(s);
    const k  = Math.sqrt(Math.max(0, 1 - m*m));
    const X = x*cs - y*sn;
    const Y = m*(x*sn + y*cs) + k*z;
    return [X, Y];
  }

  window.makeParamPath = function(spec){
    // spec uses xExpr,yExpr,tmin,tmax,step,close, stroke, strokeWidth, fill...
    const opts = spec || {};
    const env = buildEnv();
    const fx = compileExpr(String(opts.xExpr ?? "cos(t)"), ["t"]);
    const fy = compileExpr(String(opts.yExpr ?? "sin(t)"), ["t"]);
    const fz = opts.zExpr ? compileExpr(String(opts.zExpr), ["t"]) : null;
    const t0 = evalConst(opts.tmin ?? 0);
    const t1 = evalConst(opts.tmax ?? "2*pi");
    const n = Math.max(2, Number(opts.npts ?? opts.n ?? 240));
    const close = !!opts.close;

    const pts=[];
    for(let i=0;i<=n;i++){
      const t = t0 + (t1 - t0) * (i/n);
      const x = fx(t, env);
      const y = fy(t, env);
      const z = fz ? fz(t, env) : 0;
      const [Xp, Yp] = project3D(x, y, z, opts);
      pts.push({x: Xp, y: Yp});
    }
    const d = polyPath(pts, x=>x, y=>y) + (close ? " Z" : "");
    const p = document.createElementNS(NS, "path");
    p.setAttribute("d", d.trim());
    p.setAttribute("fill", opts.fill ?? "none");
    p.setAttribute("stroke", opts.stroke ?? "currentColor");
    p.setAttribute("stroke-width", String(opts.strokeWidth ?? 2));
    p.setAttribute("stroke-linecap", "round");
    p.setAttribute("stroke-linejoin", "round");
    p.setAttribute("vector-effect","non-scaling-stroke");
    if(opts.opacity!=null) p.setAttribute("opacity", String(opts.opacity));
    return p;
  };

  window.makeSurfaceLines = function(spec){
    const opts = spec || {};
    const env = buildEnv();
    const fx = compileExpr(String(opts.xExpr ?? "u"), ["u","v"]);
    const fy = compileExpr(String(opts.yExpr ?? "v"), ["u","v"]);
    const fz = opts.zExpr ? compileExpr(String(opts.zExpr), ["u","v"]) : null;

    const U0 = evalConst(opts.umin ?? -2), U1 = evalConst(opts.umax ?? 2);
    const V0 = evalConst(opts.vmin ?? -2), V1 = evalConst(opts.vmax ?? 2);
    const du = Number(opts.du ?? 0.4);
    const dv = Number(opts.dv ?? 0.4);
    const ptsStep = Number(opts.ptsStep ?? 0.08);

    const stroke = opts.stroke ?? "currentColor";
    const sw = opts.strokeWidth ?? 1;

    const g = document.createElementNS(NS, "g");
    g.setAttribute("fill","none");

    function addLine(points){
      const d = polyPath(points, x=>x, y=>y);
      const p = document.createElementNS(NS,"path");
      p.setAttribute("d", d);
      p.setAttribute("fill","none");
      p.setAttribute("stroke", stroke);
      p.setAttribute("stroke-width", String(sw));
      p.setAttribute("stroke-linecap","round");
      p.setAttribute("stroke-linejoin","round");
      p.setAttribute("vector-effect","non-scaling-stroke");
      if(opts.opacity!=null) p.setAttribute("opacity", String(opts.opacity));
      g.appendChild(p);
    }

    for(let u=U0; u<=U1+1e-9; u+=du){
      const pts=[];
      for(let v=V0; v<=V1+1e-9; v+=ptsStep){
        {
        const x = fx(u,v, env);
        const y = fy(u,v, env);
        const z = fz ? fz(u,v, env) : 0;
        const [Xp, Yp] = project3D(x, y, z, opts);
        pts.push({x: Xp, y: Yp});
      }
      }
      addLine(pts);
    }
    for(let v=V0; v<=V1+1e-9; v+=dv){
      const pts=[];
      for(let u=U0; u<=U1+1e-9; u+=ptsStep){
        {
        const x = fx(u,v, env);
        const y = fy(u,v, env);
        const z = fz ? fz(u,v, env) : 0;
        const [Xp, Yp] = project3D(x, y, z, opts);
        pts.push({x: Xp, y: Yp});
      }
      }
      addLine(pts);
    }
    return g;
  };
window.makeParamCurveSVG = makeParamCurveSVG;
  window.makeSurfaceGridSVG = makeSurfaceGridSVG;

  // optional helper: build from a spec {type:"param"/"surface", id:..., ...}
  window.buildParamUVSVG = function(spec){
    spec = spec || {};
    const t = String(spec.type || "").toLowerCase();
    if(t === "surface" || t === "uv" || t === "grid") return makeSurfaceGridSVG(spec);
    return makeParamCurveSVG(spec);
  };
})();
</script>
